<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Pattern | My Programmer's Road]]></title>
  <link href="http://ssledz.github.io/blog/categories/pattern/atom.xml" rel="self"/>
  <link href="http://ssledz.github.io/"/>
  <updated>2016-12-09T11:53:16+01:00</updated>
  <id>http://ssledz.github.io/</id>
  <author>
    <name><![CDATA[Sławomir Śledź]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Context Free Grammar Will Help Where Regex Pattern Fail - Is This Well Formed Array ?]]></title>
    <link href="http://ssledz.github.io/blog/2015/08/17/context-free-grammar-will-help-where-regex-pattern-fail-is-this-well-formed-array/"/>
    <updated>2015-08-17T00:04:55+02:00</updated>
    <id>http://ssledz.github.io/blog/2015/08/17/context-free-grammar-will-help-where-regex-pattern-fail-is-this-well-formed-array</id>
    <content type="html"><![CDATA[<h3 id="preface">Preface</h3>
<p>Some times ago I was scanning Stackoverflow to find a puzzle to solve, and I found one guy was trying to write a piece of software which had needed to answer on one simple question. Is given expression a <strong>well formed array</strong>? He was searching for a ready to use regular expression but he failed, because this puzzle can’t be solved using regex engine. Why, I will explain later but now I can say that this puzzle can be easily solved using <strong>Context free grammar</strong>.</p>

<h3 id="well-formed-array">Well formed array</h3>
<p>You can ask what does the <strong>well formed array</strong> mean ? I will try to answer by providing some positive and negative examples of such arrays.
<code>
[1 2 [-34 7] 34]
[1 2 [-34] [7] 34]
[1 2 [-34 [7] 34]]
[1 2[-34[7]34]]
[]
[[[]]]
</code>
Above are well formed arrays. In opposite below are expressions which are not syntactically consistent with the definition of well formed array.
<code>
[1 2 -34 7] 34]
[1 2 [-34 [7] 34]
[][]
</code>
Studying those examples we can try to answer on this question. So well formed array is an expression which fulfills following requirements</p>

<ul>
  <li>first, no blank, character is an open brace <code>'['</code></li>
  <li>the last no blank character needs to be a closed brace</li>
  <li>inside array, integers and other well formed arrays can appear</li>
  <li>integers are separated with at least one blank character</li>
</ul>

<h3 id="why-not-regex-">Why not regex ?</h3>
<p>Let’s simplified our example. Let’s say that we want to write a regular expression which will generate following words <script type="math/tex">w=( [^n\quad ]^n\quad|\quad n >= 1 )</script>
<code>
[]
[[]]
[[]]
[[[]]]
</code>
You can notice that the mention above strings are a subset of the set of strings which we want to parse. And here I don’t have also good news. We can’t use regex engine to parse such strings.
Why is it not possible ? Simply speaking regex engine modeled by a <strong>Finite Automata (FA)</strong> can’t count how many <code>'['</code> we have already used and check that the same number of <code>']'</code> must appear just after the last <code>'['</code>. <strong>FA</strong> doesn’t have stack to remember such things. If You are curious about formal proof you can try to google <strong>Pumping Lemma</strong> phrase. <strong>Pumping Lemma</strong> provides You a useful tool to proof if a given language (set of words which fulfill given conditions) is not a regular.</p>

<h3 id="context-free-grammar">Context free grammar</h3>
<p>I have already mentioned that to solve our problem (if a given array is well formed) we need to write a parser of some <strong>context free grammar</strong>. The model of <strong>Context free grammar</strong> is a <strong>Finite Automata</strong> with a <strong>stack</strong>. Thanks to this an Automat is able to remember some facts that have happened (e.g count braces). To write a parser we need first to write down a grammar for expression of <strong>well formed array</strong>. To do this I will use <strong>ebnf</strong> (Extended Backus–Naur Form) form.
<code>
array = "[", { array-body }, "]" 
array-body = number | array
number = [ "-" ], digit, { digit }
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
</code>
Now we are ready to write a parser.  To be precise I will use top-down parsing strategy which let me directly transform written above grammar into set of recursively called procedures.</p>

<h3 id="parser">Parser</h3>

<p>It is a good manner to split parser into 2 parts</p>

<ul>
  <li>lexer</li>
  <li>parser</li>
</ul>

<p>Lexer is responsible for grouping letters into tokens. In our grammar we have 4 kinds of tokens</p>

<ul>
  <li><code>'['</code> (<strong>LB</strong>)</li>
  <li><code>']'</code> (<strong>RB</strong>)</li>
  <li>number (<strong>NUMBER</strong>)</li>
  <li>end - token informing that there is no letter left on input  (<strong>END</strong>)</li>
</ul>

<p>Tokens are expressed by a class <code>Token</code> written below</p>

<p>```java
public class Token {</p>

<pre><code>public enum Type {
    LB, RB, NUMBER, END
}

private final Type type;
private final String value;

public Token(Type type, String value) {
    this.type = type;
    this.value = value;
}

public Type getType() {
    return type;
}

public String getValue() {
    return value;
}

@Override
public String toString() {
    final StringBuilder sb = new StringBuilder("Token[");
    sb.append("type=").append(type);
    sb.append(", value='").append(value).append('\'');
    sb.append(']');
    return sb.toString();
} } ```
</code></pre>

<h4 id="lexer">Lexer</h4>

<p>```java
public class Lexer {</p>

<pre><code>private int current;
private String input;

public Lexer(String input) {
    this.input = input;
}

private char getChar() {
    return input.charAt(current++);
}

private void unputChar() {
    current--;
}

private boolean hasNextChar() {
    return current &lt; input.length();
}

public Token next() {

    if (!hasNextChar()) {
        return new Token(Type.END, "");
    }

    char c = getChar();

    while (Character.isWhitespace(c)) {
        c = getChar();
    }

    if (c == '[') {
        return new Token(Type.LB, "[");
    }

    if (c == ']') {
        return new Token(Type.RB, "]");
    }

    int s = 1;
    if (c == '-') {
        s = -1;
    } else {
        unputChar();
    }

    StringBuilder buffer = new StringBuilder();
    while (hasNextChar()) {

        c = getChar();

        if (Character.isDigit(c)) {
            buffer.append(c);
        } else {
            unputChar();
            break;
        }

    }

    return new Token(Type.NUMBER, s &gt; 0 ? buffer.toString() : "-" + buffer.toString());

} } ```
</code></pre>

<h4 id="parser-1">Parser</h4>

<p>```java
public class Parser {</p>

<pre><code>private Lexer lexer;
private Token currentToken;

private boolean match(Type type) {
    return type == currentToken.getType();
}

private void consume(Type type) {
    if (!match(type)) {
        throw new RuntimeException(String.format("Should be %s is %s", type.name(), currentToken.getType().name()));
    }
    currentToken = lexer.next();
}

private void array() {

    consume(Type.LB);

    while (true) {

        if (match(Type.NUMBER)) {
            consume(Type.NUMBER);
        } else if (match(Type.LB)) {
            array();
        } else {
            break;
        }

    }

    consume(Type.RB);
}


private void parse(String line) {

    lexer = new Lexer(line);
    currentToken = lexer.next();

    array();
    consume(Type.END);

}

public boolean isWellFormedArray(String line) {

    try {
        parse(line);
        return true;
    } catch (Exception e) {
        System.out.println(String.format("%s is not a proper array because %s", line, e.getMessage()));
        return false;
    }

}
</code></pre>

<p>}
<code>
</code>java
public class ParserTest {</p>

<pre><code>@Test
public void testIsWellFormedArray() throws Exception {

    Parser parser = new Parser();
    assertThat(parser.isWellFormedArray("[1 2 [-34 7] 34]"), equalTo(true));
    assertThat(parser.isWellFormedArray("[1 2 -34 7] 34]"), equalTo(false));
    assertThat(parser.isWellFormedArray("[1 2 [-34] [7] 34]"), equalTo(true));
    assertThat(parser.isWellFormedArray("[1 2 [-34 [7] 34]"), equalTo(false));
    assertThat(parser.isWellFormedArray("[1 2 [-34 [7] 34]]"), equalTo(true));
    assertThat(parser.isWellFormedArray("[]"), equalTo(true));
    assertThat(parser.isWellFormedArray("[][]"), equalTo(false));
    assertThat(parser.isWellFormedArray("[[]]"), equalTo(true));
    assertThat(parser.isWellFormedArray("[1 2[-34[7]34]]"), equalTo(true));

} } ```
</code></pre>
]]></content>
  </entry>
  
</feed>

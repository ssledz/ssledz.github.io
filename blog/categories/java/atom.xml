<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | My Programmer's Road]]></title>
  <link href="http://ssledz.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://ssledz.github.io/"/>
  <updated>2015-08-09T22:46:33+02:00</updated>
  <id>http://ssledz.github.io/</id>
  <author>
    <name><![CDATA[Sławomir Śledź]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Puzzle - Write a Method That Return All Subsets of a Set]]></title>
    <link href="http://ssledz.github.io/blog/2015/08/09/puzzle-write-a-method-that-return-all-subsets-of-a-set/"/>
    <updated>2015-08-09T21:52:26+02:00</updated>
    <id>http://ssledz.github.io/blog/2015/08/09/puzzle-write-a-method-that-return-all-subsets-of-a-set</id>
    <content type="html"><![CDATA[<h3>Problem</h3>

<p>Write a method <code>public static Set&lt;Set&lt;String&gt;&gt; subsets(Set&lt;String&gt; set)</code> which returns all subsets of a given set. From mathematics point of view we need to compute the power set of the given set. The number of such subsets can be easily computed because it just 2 to the power of &lsquo;number of element in a set&rsquo;. So for a set consisting of <code>3</code> elements it is 8.  To proceed let&rsquo;s write some examples.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>subsets({&lsquo;a&rsquo;}) = {} + {&lsquo;a&rsquo;}
</span><span class='line'>subsets({&lsquo;b&rsquo;}) = {} + {&lsquo;b&rsquo;}
</span><span class='line'>subsets({&lsquo;c&rsquo;}) = {} + {&lsquo;c&rsquo;}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;subsets({&lsquo;b&rsquo;,&lsquo;c&rsquo;}) = {} + {&lsquo;b&rsquo;} + {&lsquo;c&rsquo;} + {&lsquo;b&rsquo;,&lsquo;c&rsquo;}
</span><span class='line'>subsets({&lsquo;a&rsquo;,&lsquo;c&rsquo;}) = {} + {&lsquo;a&rsquo;} + {&lsquo;c&rsquo;} + {&lsquo;a&rsquo;,&lsquo;c&rsquo;}
</span><span class='line'>subsets({&lsquo;a&rsquo;,&lsquo;b&rsquo;}) = {} + {&lsquo;a&rsquo;} + {&lsquo;b&rsquo;} + {&lsquo;a&rsquo;,&lsquo;b&rsquo;}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;subsets({&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo;}) = {} + {&lsquo;a&rsquo;} + {&lsquo;a&rsquo;,&lsquo;b&rsquo;} + {&lsquo;a&rsquo;,&lsquo;c&rsquo;} + {&lsquo;a&rsquo;,&lsquo;b&rsquo;,&lsquo;c&rsquo;} + {&lsquo;b&rsquo;} + {&lsquo;b&rsquo;,&lsquo;c&rsquo;} + {&lsquo;c&rsquo;}</span></code></pre></td></tr></table></div></figure></p>

<p>Based on that we can notice a following pattern
<code>
subset('a')            = {}, {'a'}
subset('b')            = {}, {'b'}
subset('c')            = {}, {'c'}
subsets({'b','c'})     = subset({'b'}) + subset({'c'}) + {'b','c'}
subsets({'a','c'})     = subset({'a'}) + subset({'c'}) + {'a','c'}
subsets({'a','b'})     = subset({'a'}) + subset({'b'}) + {'a','b'}
subsets({'a','b','c'}) = subsets({'b','c'}) + subsets({'a','c'}) + subsets({'a','b'}) + {'a','b','c'}
</code></p>

<h3>Coding</h3>

<pre><code class="java">    public static Set&lt;Set&lt;String&gt;&gt; subsets(Set&lt;String&gt; set) {

        if (set.size() == 1) {
            Set&lt;Set&lt;String&gt;&gt; ret = new HashSet&lt;&gt;();
            ret.add(new HashSet&lt;&gt;());
            ret.add(new HashSet&lt;&gt;(set));
            return ret;
        }

        Set&lt;Set&lt;String&gt;&gt; ret = new HashSet&lt;&gt;();
        ret.add(set);

        for (String e : set) {

            Set&lt;String&gt; newSet = new HashSet&lt;&gt;(set);
            newSet.remove(e);
            Set&lt;Set&lt;String&gt;&gt; subsets = subsets(newSet);
            ret.addAll(subsets);

        }
        return ret;

    }
</code></pre>

<pre><code>    public static void main(String[] args) {
        Set&lt;String&gt; set  = new HashSet&lt;&gt;(Arrays.asList("a", "b", "c", "d"));

        Set&lt;Set&lt;String&gt;&gt; subs = subsets(set);
        System.out.println("size: " + subs.size());
        for(Set&lt;String&gt; sub : subs) {
            System.out.println(sub.toString());
        }
    }
</code></pre>

<pre><code>size: 16
[]
[a]
[b]
[c]
[a, b]
[d]
[a, c]
[b, c]
[a, d]
[b, d]
[a, b, c]
[c, d]
[a, b, d]
[a, c, d]
[b, c, d]
[a, b, c, d]
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Puzzle - Write a Method to Reverse a String Using Recursion]]></title>
    <link href="http://ssledz.github.io/blog/2015/08/09/puzzle-write-a-method-to-reverse-a-string-using-recursion/"/>
    <updated>2015-08-09T20:25:16+02:00</updated>
    <id>http://ssledz.github.io/blog/2015/08/09/puzzle-write-a-method-to-reverse-a-string-using-recursion</id>
    <content type="html"><![CDATA[<h3>Problem</h3>

<p>I bet that everyone who is reading this know how to write a method to revers the string, but does everyone know how to do it using recursion ? To face such puzzle it it always a good idea to write first some results for given arguments and try to find a pattern. There always must be a &lsquo;base case&rsquo; which can&rsquo;t be divided into subproblems. We also need to discover a procedure which solves bigger problem using its smaller subproblems.</p>

<p>So let&rsquo;s say we need to write a method <code>public static String revers(String arg)</code> which for a given argument returns a reversed string. Below I have written some examples.
<code>
revers('a')     = 'a'
revers('ab')    = 'ba'
revers('abc')   = 'cba'
revers('abcd')  = 'dcba'
revers('abcde') = 'edcba'
</code>
Based on that we can already write a recursive procedure.
<code>
revers('a')     = 'a'
revers('ab')    = 'b'|revers('a')
revers('abc')   = 'c'|revers('ab')
revers('abcd')  = 'd'|revers('abc')
revers('abcde') = 'e'|revers('abcd')
</code>
To compute a reversed string for <code>'a'</code> we need to return that string and it is our &lsquo;base case&rsquo;. In other cases to compute a reversed string we need to get the last char and concatenate it with the reversed string without that last character.</p>

<p>I think we are ready to write some code.</p>

<h3>Coding</h3>

<pre><code class="java">    public static String revers(String arg) {

        if (arg.length() == 1) {
            return arg;
        }
        return arg.charAt(arg.length() - 1) + revers(arg.substring(0, arg.length() - 1));

    }
</code></pre>

<pre><code class="java">    public static void main(String[] args) {
        System.out.println(revers("a"));
        System.out.println(revers("ab"));
        System.out.println(revers("abc"));
        System.out.println(revers("abcd"));
        System.out.println(revers("abcde"));
    }
</code></pre>

<pre><code>a
ba
cba
dcba
edcba
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Puzzle - Write a Method to Compute All Permutations of a String]]></title>
    <link href="http://ssledz.github.io/blog/2015/08/08/puzzle-write-a-method-to-compute-all-permutations-of-a-string/"/>
    <updated>2015-08-08T21:06:54+02:00</updated>
    <id>http://ssledz.github.io/blog/2015/08/08/puzzle-write-a-method-to-compute-all-permutations-of-a-string</id>
    <content type="html"><![CDATA[<h3>How to Approche</h3>

<p>When we hear a problem beginning with: &lsquo;Write a method to compute all&hellip;&rsquo;, it is often a good candidate for recursion. By definition recursive solutions are built of solving subproblems. Simply speaking when we need to compute <code>f(n)</code>, we need first to solve a problem for <code>f(n-1)</code>, to solve the problem for <code>f(n-1)</code> we need to do the same for <code>f(n-2)</code> and so on. Always at the end we need to face so called &lsquo;base case&rsquo; - <code>f(0)</code> or <code>f(1)</code>, which is the most easiest subproblem. Good news is that for this problem we know a solution and  many times it is just a hard coded value.</p>

<h4>Problem</h4>

<p>Our task is to write a function <code>List&lt;String&gt;perm(String str)</code> which will return all permutations of a string given in the argument. To proceed let&rsquo;s think how this problem can be splitted into smaller subproblems and how to connect those problems in the recursive way.</p>

<p>To find a pattern we will write all permutations of following strings <code>'a'</code>, <code>'b'</code>, <code>'c'</code>, <code>'ab'</code>, <code>'ac'</code>, <code>'bc'</code>, <code>'abc'</code>
<code>
perm('a')   = 'a'
perm('b')   = 'b'
perm('c')   = 'c'
perm('ab')  = 'ab', 'ba'
perm('ac')  = 'ac', 'ca'
perm('bc')  = 'bc', 'cb'
perm('abc') = 'abc', 'acb', 'bac', 'bca', 'cab', 'cba'
</code></p>

<p>If You have some experience in solving such puzzles You probably noticed a following pattern</p>

<pre><code>perm('a')   = 'a'
perm('b')   = 'b'
perm('c')   = 'c'
perm('ab')  = 'a'|perm('b')  + 'b'|perm('a')
perm('ac')  = 'a'|perm('c')  + 'c'|perm('a')
perm('bc')  = 'b'|perm('c')  + 'c'|perm('b')
perm('abc') = 'a'|perm('bc') + 'b'|perm('ac') + 'c'|perm('ab')
</code></pre>

<p>where <code>|</code> means a concatenation of two strings.</p>

<p>First three cases are called &lsquo;base cases&rsquo; and as I mentioned before they can be easily solved. A permutation of a string containing one character is just the same string. At this point of analysis we can now try to write a small program which will solve our problem.</p>

<h3>Coding</h3>

<pre><code class="java">    public static List&lt;String&gt; permute(String str) {

        if (str.length() == 1) {
            List&lt;String&gt; ret = new LinkedList&lt;&gt;();
            ret.add(str);
            return ret;
        }

        List&lt;String&gt; permutations = new LinkedList&lt;&gt;();

        for (int i = 0; i &lt; str.length(); i++) {
            String left = "" + str.charAt(i);
            StringBuilder subStr = new StringBuilder(str);
            subStr.deleteCharAt(i);

            List&lt;String&gt; subPermutations = permute(subStr.toString());

            for (String perm : subPermutations) {
                permutations.add(left + perm);
            }

        }

        return permutations;

    }
</code></pre>

<pre><code class="java">    public static void main(String[] args) {

        List&lt;String&gt; permutations = permute("abc");
        System.out.println(String.format("permutations size: %d", permutations.size()));
        for (String perm : permutations) {
            System.out.println(perm);
        }
    }
</code></pre>

<pre><code>permutations size: 6
abc
acb
bac
bca
cab
cba
</code></pre>
]]></content>
  </entry>
  
</feed>

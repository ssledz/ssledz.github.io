
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>ssledz blog</title>
  <meta name="author" content="Sławomir Śledź">

  
  <meta name="description" content="Tail call optimization (or tail call elimination) allows recursive functions to re-use the stack frame instead of creating new frames on every call. &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://ssledz.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="ssledz blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  messageStyle: "none",
  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-66120423-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">ssledz blog</a></h1>
  
    <h2>Everything should be made as simple as possible, but no simpler.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="ssledz.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2021/01/13/recursive-tail-call-optimization-and-trampoline/">Recursive Tail Call Optimization and Trampoline</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2021-01-13T14:04:26+01:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>13</span><span class='date-suffix'>th</span>, <span class='date-year'>2021</span></span> <span class='time'>2:04 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Tail call optimization (or tail call elimination) allows recursive functions to re-use the stack frame instead of creating new frames on every call.</p>

<p>Thanks to that an author of recursive function in tail position is not constrained by the stack size. 
More over such a function runs faster than the function without optimization, because calling a function doesn’t create a new stack frame which is time 
and resource consuming operation.</p>

<p>The article can be found <a href="https://iiit.pl/7743-2/">here</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2020/09/23/object-oriented-programming-vs-functional-programming/">Object Oriented Programming vs Functional Programming</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2020-09-23T22:47:04+02:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2020</span></span> <span class='time'>10:47 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Michael Feathers, the author of Working with Legacy Code, described in a neat way the difference between 
object and functional oriented programming:</p>

<blockquote>
  <blockquote>
    <p>OO makes code understandable by encapsulating moving parts. FP makes code understandable by minimizing moving parts.</p>
  </blockquote>
</blockquote>

<p>More can be found <a href="https://iiit.pl/object-oriented-programming-vs-functional-programming/?fbclid=IwAR2YnoVVf3dJMXOHkcGifpNVLklH636q0P21gvjISI4-s2UbkDrfal9KYAE">here</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2020/04/26/static-linking-with-ghc/">Static Linking With Ghc</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2020-04-26T21:21:12+02:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2020</span></span> <span class='time'>9:21 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>In order to compile a given source code using static linking</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="c1">-- Main.hs</span>
</span><span class="line"><span class="nf">main</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="s">&quot;Hello World!&quot;</span>
</span></code></pre></td></tr></table></div></figure>

<p>there is a need to pass two additional flags to <code>ghc</code> like</p>

<ul>
  <li><code>-optl-static</code></li>
  <li><code>-optl-pthread</code></li>
</ul>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="nv">$ </span>ghc -optl-static -optl-pthread --make Main
</span></code></pre></td></tr></table></div></figure>

<p>then</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="nv">$ </span>file Main
</span><span class="line">Main: ELF 64-bit LSB executable, x86-64, version <span class="m">1</span> <span class="o">(</span>SYSV<span class="o">)</span>, statically linked,
</span><span class="line"><span class="k">for</span> GNU/Linux 3.2.0, BuildID<span class="o">[</span>sha1<span class="o">]=</span>62d1682f378af2f994758e737ba9dc0b24fc06aa,
</span><span class="line">with debug_info, not stripped
</span></code></pre></td></tr></table></div></figure>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2019/03/10/option-monad-from-scratch/">Option Monad - From Scratch</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2019-03-10T11:28:42+01:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2019</span></span> <span class='time'>11:28 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>In a post <a href="/blog/2019/01/28/about-monads-a-gentle-introduction/">About Monads - a gentle introduction</a>
I have introduced a concept of <code>monad</code>. Since now we should have a good
intuition what <code>monad</code> is and be aware of the situations where 
it can be used to simplify the code and make it more readable.</p>

<p>In this post we will focus on an <code>Option</code> monad which wraps value in a context 
aware of whether or not the value exists. We will start with a problem and solution
not exactly suiting our needs and by adapting <code>Option</code> monad we will try to fix this.</p>

<h2 id="problem">Problem</h2>

<p>There are 3 streams of numbers given as a strings.</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;0&quot;</span><span class="o">,</span> <span class="s">&quot;9&quot;</span><span class="o">,</span> <span class="s">&quot;9&quot;</span><span class="o">)</span>
</span><span class="line"><span class="k">val</span> <span class="n">ys</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;3&quot;</span><span class="o">,</span> <span class="s">&quot;3&quot;</span><span class="o">,</span> <span class="s">&quot;1&quot;</span><span class="o">)</span>
</span><span class="line"><span class="k">val</span> <span class="n">zs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;2&quot;</span><span class="o">,</span> <span class="s">&quot;3&quot;</span><span class="o">,</span> <span class="s">&quot;2&quot;</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>
<p>After zipping and flattening we got a stream  called <code>data</code> containing tuples
of 3 strings</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">val</span> <span class="n">data</span> <span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="n">flatten</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">ys</span><span class="o">).</span><span class="n">zip</span><span class="o">(</span><span class="n">zs</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>
<p>Our task is to build a pipeline that generates a stream of <code>Doubles</code> 
which is a result of division one number by another in a sequence in the 
context of the same tuple.</p>

<p>It means that the pipeline for a stream described as</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="o">[(</span><span class="kt">x1</span>,<span class="kt">y1</span>,<span class="kt">z1</span><span class="o">)</span>, <span class="o">(</span><span class="kt">x2</span>,<span class="kt">y2</span>,<span class="kt">z2</span><span class="o">)</span>,<span class="kt">...</span><span class="o">(</span><span class="kt">xn</span>,<span class="kt">yn</span>,<span class="kt">zn</span><span class="o">)]</span>
</span></code></pre></td></tr></table></div></figure>
<p>should generate a stream of numbers given by formula mentioned below</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="o">[(</span><span class="kt">x1/y1/z1</span><span class="o">)</span>, <span class="o">(</span><span class="kt">x2/y2/z2</span><span class="o">)</span>,<span class="kt">...</span> <span class="o">(</span><span class="kt">xn/yn/zn</span><span class="o">)]</span>
</span></code></pre></td></tr></table></div></figure>
<p>This problem can be solved using following scala code</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">def</span> <span class="n">pipeline</span> <span class="k">=</span> <span class="n">data</span>
</span><span class="line">    <span class="o">.</span><span class="n">map</span><span class="o">((</span><span class="nc">DivModule</span><span class="o">.</span><span class="n">div</span> <span class="k">_</span><span class="o">).</span><span class="n">tupled</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>
<p><code>div</code> function is defined in <code>DivModule</code></p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">object</span> <span class="nc">DivModule</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">parse</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;arg can&#39;t be null&quot;</span><span class="o">)</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">x</span><span class="o">.</span><span class="n">toDouble</span>
</span><span class="line">
</span><span class="line">  <span class="o">}</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">div</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">z</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">y</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">z</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;(x | y | z) can&#39;t be null&quot;</span><span class="o">)</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">val</span> <span class="n">xx</span> <span class="k">=</span> <span class="n">parse</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">    <span class="k">val</span> <span class="n">yy</span> <span class="k">=</span> <span class="n">parse</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">    <span class="k">val</span> <span class="n">zz</span> <span class="k">=</span> <span class="n">parse</span><span class="o">(</span><span class="n">z</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="o">(</span><span class="n">yy</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">zz</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;y or z can&#39;t be 0&quot;</span><span class="o">)</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">xx</span> <span class="o">/</span> <span class="n">yy</span> <span class="o">/</span> <span class="n">zz</span>
</span><span class="line">
</span><span class="line">  <span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
<p>For a streams of numbers defined at the beginning we should get</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="mf">0.0</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">,</span> <span class="mf">4.5</span>
</span></code></pre></td></tr></table></div></figure>
<p>The numbers are correct, but take a look on implementation of a <code>parse</code>
and <code>div</code> functions. Those functions are not <code>total</code>. In functional world a function 
which is not <code>total</code> is called <code>partial</code>. A <code>partial</code> function is not defined 
for all values passed as its arguments.</p>

<p>And for following streams of numbers</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;11&quot;</span><span class="o">,</span> <span class="s">&quot;22&quot;</span><span class="o">,</span> <span class="s">&quot;0&quot;</span> <span class="o">,</span> <span class="s">&quot;9&quot;</span><span class="o">,</span> <span class="s">&quot;9&quot;</span><span class="o">,</span> <span class="kc">null</span><span class="o">)</span>
</span><span class="line"><span class="k">val</span> <span class="n">ys</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;11&quot;</span><span class="o">,</span> <span class="s">&quot;0&quot;</span> <span class="o">,</span> <span class="s">&quot;33&quot;</span><span class="o">,</span> <span class="s">&quot;3&quot;</span><span class="o">,</span> <span class="s">&quot;3&quot;</span><span class="o">,</span> <span class="s">&quot;1&quot;</span><span class="o">)</span>
</span><span class="line"><span class="k">val</span> <span class="n">zs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;0&quot;</span> <span class="o">,</span> <span class="s">&quot;22&quot;</span><span class="o">,</span> <span class="s">&quot;33&quot;</span><span class="o">,</span> <span class="s">&quot;2&quot;</span><span class="o">,</span> <span class="s">&quot;3&quot;</span><span class="o">,</span> <span class="s">&quot;2&quot;</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>
<p>after running pipeline we get an <code>Exception</code></p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="nc">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">&quot;main&quot;</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">IllegalArgumentException</span><span class="k">:</span> <span class="kt">y</span> <span class="kt">or</span> <span class="kt">z</span> <span class="kt">can</span><span class="err">&#39;</span><span class="kt">t</span> <span class="kt">be</span> <span class="err">0</span>
</span><span class="line">  <span class="kt">at</span> <span class="kt">learning.monad.example.DivModule$.div</span><span class="o">(</span><span class="kt">DivModule.scala:</span><span class="err">28</span><span class="o">)</span>
</span><span class="line">  <span class="kt">at</span> <span class="kt">learning.monad.example.MonadOption$.$anonfun$pipeline$2</span><span class="o">(</span><span class="kt">MonadOption.scala:</span><span class="err">25</span><span class="o">)</span>
</span><span class="line">  <span class="kt">at</span> <span class="kt">learning.monad.example.MonadOption$.$anonfun$pipeline$2$adapted</span><span class="o">(</span><span class="kt">MonadOption.scala:</span><span class="err">25</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>
<p>We can easily fix this by lifting a partial function to a total function. 
Let’s add <code>lift</code> function to the <code>DivModule</code></p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">type</span> <span class="kt">Fun3</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Double</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="n">lift</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Fun3</span><span class="o">,</span> <span class="n">defaultValue</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Fun3</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class="line">  <span class="k">try</span> <span class="o">{</span>
</span><span class="line">    <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span>
</span><span class="line">  <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
</span><span class="line">    <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">Throwable</span> <span class="o">=&gt;</span> <span class="n">defaultValue</span>
</span><span class="line">  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
<p>and modify the <code>pipeline</code> accordingly</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">def</span> <span class="n">pipeline</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="n">data</span>
</span><span class="line">  <span class="o">.</span><span class="n">map</span><span class="o">((</span><span class="nc">DivModule</span><span class="o">.</span><span class="n">lift</span><span class="o">(</span><span class="nc">DivModule</span><span class="o">.</span><span class="n">div</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">)).</span><span class="n">tupled</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>
<p>Now <code>pipeline</code> generates streams of numbers like</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="o">-</span><span class="mf">1.0</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">0.0</span><span class="o">,</span> <span class="mf">1.5</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0</span>
</span></code></pre></td></tr></table></div></figure>
<p>We can spot that for each undefined value we get <code>-1</code> because of <code>lift</code> 
function which maps all undefined values to the default one, in our case <code>-1</code>.</p>

<p>In order to get only a valid numbers let’s apply a filter</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">def</span> <span class="n">pipeline</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="n">data</span>
</span><span class="line">  <span class="o">.</span><span class="n">map</span><span class="o">((</span><span class="nc">DivModule</span><span class="o">.</span><span class="n">lift</span><span class="o">(</span><span class="nc">DivModule</span><span class="o">.</span><span class="n">div</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">)).</span><span class="n">tupled</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
</span><span class="line">  <span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>and our result is</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="mf">0.0</span><span class="o">,</span> <span class="mf">1.5</span><span class="o">,</span> <span class="mf">1.0</span>
</span></code></pre></td></tr></table></div></figure>

<p>For a first look this solution would seem to be good, but what about all
variations of streams for which pipeline could return <code>-1</code> as a correct result ?</p>

<p>For example, when we change fifth number in <code>zs</code> from <code>3</code> to <code>-3</code></p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;11&quot;</span><span class="o">,</span> <span class="s">&quot;22&quot;</span><span class="o">,</span> <span class="s">&quot;0&quot;</span> <span class="o">,</span> <span class="s">&quot;9&quot;</span><span class="o">,</span> <span class="s">&quot;9&quot;</span><span class="o">,</span> <span class="kc">null</span><span class="o">)</span>
</span><span class="line"><span class="k">val</span> <span class="n">ys</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;11&quot;</span><span class="o">,</span> <span class="s">&quot;0&quot;</span> <span class="o">,</span> <span class="s">&quot;33&quot;</span><span class="o">,</span> <span class="s">&quot;3&quot;</span><span class="o">,</span> <span class="s">&quot;3&quot;</span><span class="o">,</span> <span class="s">&quot;1&quot;</span><span class="o">)</span>
</span><span class="line"><span class="k">val</span> <span class="n">zs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;0&quot;</span> <span class="o">,</span> <span class="s">&quot;22&quot;</span><span class="o">,</span> <span class="s">&quot;33&quot;</span><span class="o">,</span> <span class="s">&quot;2&quot;</span><span class="o">,</span> <span class="s">&quot;-3&quot;</span><span class="o">,</span> <span class="s">&quot;2&quot;</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>our pipeline will generate</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="mf">0.0</span><span class="o">,</span> <span class="mf">1.5</span>
</span></code></pre></td></tr></table></div></figure>

<p>instead of</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="mf">0.0</span><span class="o">,</span> <span class="mf">1.5</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0</span>
</span></code></pre></td></tr></table></div></figure>

<p>This is wrong and changing a default value in <code>lift</code> function doesn’t
fix this, because for each such case we can find a counterexample where
a correct value is filtered out. It is easy to prove that <code>div</code> function
returns numbers from the whole <code>Double</code> space. In category theory there is
a name for such functions (morphisms) - epimorphisms.</p>

<p>And here an <code>Option</code> monad comes to the rescue.</p>

<h2 id="option-monad">Option monad</h2>

<p>In order to implement an <code>Option</code> monad let’s start with defining a data type
constructor</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">trait</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>

<p><code>Option</code> is an algebraic data type constructor parametrized with <code>A</code> in a <code>co-variant</code>
position. We can think of an <code>Option[_]</code> like about container keeping
a value. For now it has no context.</p>

<p>Let’s assigned a context to it by defining a value constructor called <code>Some</code></p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">case</span> <span class="k">class</span> <span class="nc">Some</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">get</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>
<p>This constructor introduced a context of container with a none empty value.</p>

<p>A context meaning no value (empty container) can be defined with <code>None</code></p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">case</span> <span class="k">object</span> <span class="nc">None</span> <span class="k">extends</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>
<p><code>None</code> reveals why we need a type parameter <code>A</code> to be in <code>co-variant</code> position -
we simply requires <code>None</code> to be cast to any <code>Option[A]</code>.</p>

<p>Recalling a definition of <code>Monad</code> we know that it consists of three parts:</p>

<ul>
  <li>type constructor <code>M[A]</code></li>
  <li>type converter (called <code>unit</code>, <code>pure</code> or <code>return</code>)</li>
  <li>combinator (called <code>bind</code>, <code>&gt;&gt;=</code> or <code>flatMap</code>)</li>
</ul>

<p>First part is fulfilled. Now we have to implement type converter - <code>pure</code></p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">object</span> <span class="nc">Option</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="nc">None</span> <span class="k">else</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class="line">
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
<p><code>pure</code> is a function which is responsible for putting a given value
to the minimal meaningful context. For <code>Option</code> we requires that each
non <code>null</code> value should be bind to the <code>Some</code>, in other case
it should be <code>None</code>.</p>

<p>The toughest to implement is a combinator function called <code>flatMap</code>. For
an <code>Option</code> it is very easy task however.</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">trait</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
</span><span class="line">  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
</span><span class="line">    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class="line">    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
<p>This higher order function is very powerful and can be used as a primitive
to implement for example <code>map</code> and <code>filter</code> in a following way</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">trait</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
</span><span class="line">  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
</span><span class="line">    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class="line">    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">flatMap</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="nc">Option</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">filter</span><span class="o">(</span><span class="n">p</span> <span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">flatMap</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="k">if</span><span class="o">(</span><span class="n">p</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="nc">Option</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">else</span> <span class="nc">None</span><span class="o">)</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
<p>Thanks to the <code>flatMap</code> we are able to get a value from container, abstracting
whether or not the value exists or not, and apply a <code>map</code> transformation
deciding if we want to put the result again or replace container with an empty one.</p>

<p>Putting all parts together we can define <code>Option</code> monad in <code>scala</code> in the following way</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
</span><span class="line">    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class="line">    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">flatMap</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="nc">Option</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span>
</span><span class="line">
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="k">object</span> <span class="nc">Option</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="nc">None</span> <span class="k">else</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class="line">
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="k">case</span> <span class="k">class</span> <span class="nc">Some</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">get</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span><span class="line">
</span><span class="line"><span class="k">case</span> <span class="k">object</span> <span class="nc">None</span> <span class="k">extends</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="building-new-version-of-pipeline">Building new version of pipeline</h2>

<p>Let’s return to our problem. First we need to reimplement <code>parse</code></p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">def</span> <span class="n">parse</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="n">x</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">str</span> <span class="k">=&gt;</span>
</span><span class="line">  <span class="k">try</span> <span class="o">{</span>
</span><span class="line">    <span class="nc">Option</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="n">toDouble</span><span class="o">)</span>
</span><span class="line">  <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
</span><span class="line">    <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">Throwable</span> <span class="o">=&gt;</span> <span class="nc">None</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
<p>Argument and return type has been lifted respectively to 
the <code>Option[String]</code> and <code>Option[Double]</code> type. You can spot
that I have used <code>flatMap</code> to have an access to the <code>String</code> value and
based on the <code>toDouble</code> operation I returned some <code>Double</code> value or nothing -
in case of parse exception. When an argument <code>x</code> is <code>None</code> the function
passed to <code>flatMap</code> is not executed - so I am sure that <code>String</code> passed
to monadic function is not <code>null</code> and I don’t have to make awkward <code>null</code> checks.</p>

<p>Next we need to take care of <code>div</code></p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">def</span> <span class="n">div</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class="line">  <span class="k">def</span> <span class="n">zeroToNone</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">None</span> <span class="k">else</span> <span class="nc">Some</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">  <span class="k">for</span> <span class="o">{</span>
</span><span class="line">    <span class="n">xx</span> <span class="k">&lt;-</span> <span class="n">parse</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</span><span class="line">    <span class="n">yy</span> <span class="k">&lt;-</span> <span class="n">parse</span><span class="o">(</span><span class="n">y</span><span class="o">).</span><span class="n">flatMap</span><span class="o">(</span><span class="n">zeroToNone</span><span class="o">)</span>
</span><span class="line">    <span class="n">zz</span> <span class="k">&lt;-</span> <span class="n">parse</span><span class="o">(</span><span class="n">z</span><span class="o">).</span><span class="n">flatMap</span><span class="o">(</span><span class="n">zeroToNone</span><span class="o">)</span>
</span><span class="line">  <span class="o">}</span> <span class="k">yield</span> <span class="n">xx</span> <span class="o">/</span> <span class="n">yy</span> <span class="o">/</span> <span class="n">zz</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

<p><code>String</code> arguments has been lifted to the <code>Option[String]</code> and return type
is now <code>Option[Double]</code>.</p>

<p>An <code>x</code> argument is passed to the <code>parse</code> and finally we have <code>Double</code> 
value in <code>xx</code> variable. If <code>parse</code> returns <code>None</code> then
the whole function <code>div</code> is evaluated to <code>None</code>.</p>

<p>For <code>y</code> and <code>z</code> things works almost the same with one difference - we additionally requires that
<code>yy</code> an <code>zz</code> must be none zero. This is expressed by calling <code>flatMap</code>
with function <code>zeroToNone</code>. For <code>0</code> value <code>zeroToNone</code> returns an empty 
container <code>None</code> which causes that the whole expression <code>parse(y).flatMap(zeroToNone)</code>
is evaluated to <code>None</code> what moves <code>div</code> function to return <code>None</code>.</p>

<p>Finally pipeline could look following</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">def</span> <span class="n">pipeline2</span> <span class="k">=</span> <span class="n">data</span>
</span><span class="line">  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">map3</span><span class="o">(</span><span class="n">x</span><span class="o">)(</span><span class="nc">Option</span><span class="o">.</span><span class="n">pure</span><span class="o">))</span>
</span><span class="line">  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">z</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">DivModuleWithOption</span><span class="o">.</span><span class="n">div</span> <span class="k">_</span><span class="o">).</span><span class="n">tupled</span><span class="o">(</span><span class="n">z</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>

<p>This pipeline generates</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="nc">List</span><span class="o">(</span><span class="nc">None</span><span class="o">,</span> <span class="nc">None</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="mf">0.0</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mf">1.5</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(-</span><span class="mf">1.0</span><span class="o">),</span> <span class="nc">None</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>At the end we need only to filter out nones and get the value out of the <code>Option</code></p>

<p>To do so there is a need to add 3 additional methods to <code>Option</code></p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="c1">//skipped for brevity</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">isNonEmpty</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">!</span><span class="n">isEmpty</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">get</span> <span class="k">:</span> <span class="kt">A</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>and to corresponding subclasses</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">case</span> <span class="k">class</span> <span class="nc">Some</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">get</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class="line">  <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="k">case</span> <span class="k">object</span> <span class="nc">None</span> <span class="k">extends</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="o">{</span>
</span><span class="line">  <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">get</span> <span class="k">:</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="o">???</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>Finally the pipeline</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">def</span> <span class="n">pipeline2</span> <span class="k">=</span> <span class="n">data</span>
</span><span class="line">  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">map3</span><span class="o">(</span><span class="n">x</span><span class="o">)(</span><span class="nc">Option</span><span class="o">.</span><span class="n">pure</span><span class="o">))</span>
</span><span class="line">  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">z</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">DivModuleWithOption</span><span class="o">.</span><span class="n">div</span> <span class="k">_</span><span class="o">).</span><span class="n">tupled</span><span class="o">(</span><span class="n">z</span><span class="o">))</span>
</span><span class="line">  <span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">isNonEmpty</span><span class="o">)</span>
</span><span class="line">  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">get</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>generates following stream of numbers</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="nc">List</span><span class="o">(</span><span class="mf">0.0</span><span class="o">,</span> <span class="mf">1.5</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>and this is all we need.</p>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://github.com/ssledz/ssledz.github.io-src/tree/master/monad-intro-session">Sources to the post</a></li>
  <li><a href="https://github.com/ssledz/ssledz.github.io-src/tree/master/monad-gentle-introduction">Implement monad from scratch - github sources</a></li>
  <li><a href="/blog/2019/01/28/about-monads-a-gentle-introduction/">About Monads - a gentle introduction</a></li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2019/02/17/monads-lunch2learn-session/">Monads - Lunch2Learn Session</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2019-02-17T13:33:47+01:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2019</span></span> <span class='time'>1:33 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Slides for Lunch2Learn (L2L) session are available <a href="/presentations/monads-intro.html">here</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2019/01/28/about-monads-a-gentle-introduction/">About Monads - a Gentle Introduction</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2019-01-28T00:23:36+01:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2019</span></span> <span class='time'>12:23 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>In functional programming monad is a design pattern which is used to
express how states of computations are changing. It can take a form of some
abstract data type constructor with two abstract functions.</p>

<p>In <code>scala</code> we can define this contract using <code>Monad</code> type class</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">trait</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">M</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">flatMap</span><span class="o">(</span><span class="n">xs</span><span class="o">)(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">pure</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span>
</span><span class="line">
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>Functions <code>pure</code> and <code>flatMap</code> for a given monad <code>M[_]</code> have to follow
some laws - I will talk about them later.</p>

<p>Function <code>map</code> can be defined
in terms of <code>flatMap</code> and <code>pure</code> and this is a bonus which we get for a free
when we provide an instance of a Monad for a type <code>M[_]</code>. Moreover many useful
functions can be defined in terms of <code>flatMap</code> and <code>pure</code> like <code>map2</code>, <code>ap</code>,
<code>filter</code> and so on. This interface is so powerful then often is treated
as a primitive one when goes to implement other functions.</p>

<p>We can think about <code>M[A]</code> like about some smart container
for a value (values) of type <code>A</code>. This container abstracts away from how this value
is kept. We can have many flavors of them like container:</p>

<ul>
  <li>aware of whether or not the value exists</li>
  <li>with more then one value</li>
  <li>for which getting the value would trigger some kind of <code>IO</code> operation</li>
  <li>with value which eventually could appear in future</li>
  <li>with value or error</li>
  <li>with value dependent on some kind of state</li>
  <li>with value and some logging information</li>
  <li>etc</li>
</ul>

<p><code>Monad</code> let us focus on what we want to do with the contained value. <code>Monad</code> is
like a <code>context</code> in which the value exists. When we want to do some computation
we are abstracting over the context so we aren’t disrupted whether or
not the value exists, we have many of them or the value may appear in a future.
We want just to get the value out of the container for a moment to make
some computation and then put it there again. The <code>context</code> is important only when
we want to pull out a value permanently.</p>

<p>Another advantage of the <code>monad</code> is an ability of sequencing the computations.
Having let’s say two computations we can very easily make dependence
between them saying that the computations of the second depends on
a result of the first. Of course this can be scaled to more than two.</p>

<p>At first glance, it may seem to be not so impressive because it is
very common to make such things during coding. But be aware that monad
frees us from thinking about the context in which the value exists. The context
can be for example an asynchronous computation. Dealing with concurrency
is challenging - we have to be very careful to not make a hard to spot mistakes.
Monad takes care about this complexity, providing a result of the
first computation as soon as possible giving us possibility to
spawn another computation in asynchronous manner.</p>

<h3 id="laws">Laws</h3>
<p>Each monad needs to follow three laws</p>

<ul>
  <li>Left identity: <code>return a &gt;&gt;= f ≡ f a</code></li>
  <li>Right identity: <code>m &gt;&gt;= return ≡ m</code></li>
  <li>Associativity: <code>(m &gt;&gt;= f) &gt;&gt;= g ≡ m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code></li>
</ul>

<p>These laws was taken from haskell because expressions there are very compact and
easy to follow. Function <code>&gt;&gt;=</code> in scala maps to <code>flatMap</code>, <code>return</code> is
just a <code>pure</code>, <code>f x</code> is an application of function <code>f</code> with <code>x</code> and the
last one <code>\x -&gt; ...</code> is a lambda expression.</p>

<p>Laws in scala can be written in a following way (using ScalaCheck)</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">val</span> <span class="n">monad</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">Monad</span><span class="o">[</span><span class="kt">M</span><span class="o">]]</span>
</span><span class="line">
</span><span class="line"><span class="n">property</span><span class="o">(</span><span class="s">&quot;Left identity: return a &gt;&gt;= f ≡ f a&quot;</span><span class="o">)</span> <span class="k">=</span> <span class="n">forAll</span> <span class="o">{</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">M</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=&gt;</span>
</span><span class="line">  <span class="o">(</span><span class="n">`return`</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span><span class="o">)</span> <span class="o">===</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="n">property</span><span class="o">(</span><span class="s">&quot;Right identity: m &gt;&gt;= return ≡ m&quot;</span><span class="o">)</span> <span class="k">=</span> <span class="n">forAll</span> <span class="o">{</span> <span class="n">m</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span>
</span><span class="line">  <span class="o">(</span><span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">`return`</span><span class="o">)</span> <span class="o">===</span> <span class="n">m</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="n">property</span><span class="o">(</span><span class="s">&quot;Associativity: (m &gt;&gt;= f) &gt;&gt;= g ≡ m &gt;&gt;= (\\x -&gt; f x &gt;&gt;= g)&quot;</span><span class="o">)</span> <span class="k">=</span>
</span><span class="line">  <span class="n">forAll</span> <span class="o">{</span> <span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">M</span><span class="o">[</span><span class="kt">B</span><span class="o">],</span> <span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">M</span><span class="o">[</span><span class="kt">C</span><span class="o">])</span> <span class="k">=&gt;</span>
</span><span class="line">    <span class="o">((</span><span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span><span class="o">)</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span><span class="o">)</span> <span class="o">===</span> <span class="o">(</span><span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span><span class="o">))</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="k">val</span> <span class="n">`return`</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">monad</span><span class="o">.</span><span class="n">pure</span> <span class="k">_</span>
</span><span class="line">
</span><span class="line"><span class="k">private</span> <span class="k">implicit</span> <span class="k">class</span> <span class="nc">MonadOps</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">m</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
</span><span class="line">  <span class="k">def</span> <span class="o">&gt;&gt;=[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">M</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">monad</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">m</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
<p>If you are curious about implementation details take a look on this <a href="https://raw.githubusercontent.com/ssledz/ssledz.github.io-src/master/monad-gentle-introduction/src/test/scala/monad/intro/AbstractMonadProperties.scala">class</a></p>

<h3 id="flavors-of-monads">Flavors of monads</h3>

<p>This section is a placeholder for a list of posts about monads mentioned in
this article. I will try my best to deliver a missing content. Watch my blog
for an update.</p>

<p>Monads:</p>

<ul>
  <li><a href="/blog/2019/03/10/option-monad-from-scratch/">Option</a></li>
  <li>Either</li>
  <li>Id</li>
  <li>Writer</li>
  <li>Reader</li>
  <li>State</li>
  <li>Try</li>
  <li>IO</li>
  <li>List</li>
</ul>

<h3 id="resources">Resources</h3>

<ul>
  <li><a href="https://www.quora.com/What-are-monads-in-functional-programming-and-why-are-they-useful-Are-they-a-generic-solution-to-the-problem-of-state-in-FP-or-Haskell-specific-Are-they-specific-to-Haskell-or-are-they-encountered-in-other-FP-languages">What are monads in functional programming and why are they useful?</a></li>
  <li><a href="http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html">You Could Have Invented Monads!</a></li>
  <li><a href="https://dev.to/theodesp/explain-monads-like-im-five">Explain Monads Like I’m five</a></li>
  <li><a href="https://wiki.haskell.org/All_About_Monads">All About Monads</a></li>
  <li><a href="https://www.haskell.org/tutorial/monads.html">A Gentle Introduction to Haskell</a></li>
  <li><a href="http://learnyouahaskell.com/a-fistful-of-monads">A Fistful of Monads</a></li>
  <li><a href="https://github.com/ssledz/ssledz.github.io-src/tree/master/monad-gentle-introduction">Sources to the post</a></li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2019/01/24/monad-transformers-part-2/">Monad Transformers - Part 2</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2019-01-24T21:46:06+01:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2019</span></span> <span class='time'>9:46 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>In a previous <a href="/blog/2018/12/18/monad-transformers-a-quick-recap/">post</a>
I introduced monad transformers and since now we should have a good feeling
about their usage and how they can be helpful.</p>

<p>Designing a monad transformer we decided to fix inner most monad. This
decision was dictated by the fact that we couldn’t replace code dependent
on internal representation of that inner most monad. I think that this step
could not be as obvious as I expected to be. And now I will try to
make it more clear.</p>

<p>Let’s try to bite the problem from different side. Assume that we can write
a monad transformer and know nothing about monads internal representation.
Let’s call it <code>CMonad</code> (shorthand from <code>ComposedMonad</code>).</p>

<p>Such a class could look like</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">case</span> <span class="k">class</span> <span class="nc">CMonad</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line"> <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">G</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class="line">   <span class="o">???</span>
</span><span class="line">
</span><span class="line"> <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span><span class="line">
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
<p>Here <code>F[_]</code> and <code>G[_]</code> are higher kinded type representing outer and inner most monad.</p>

<p>Then a problem introduced in a previous post could be solved following</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">def</span> <span class="n">findStreetByLogin</span><span class="o">(</span><span class="n">login</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">CMonad</span><span class="o">[</span><span class="kt">Future</span>, <span class="kt">Option</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
</span><span class="line">  <span class="k">for</span> <span class="o">{</span>
</span><span class="line">    <span class="n">user</span> <span class="k">&lt;-</span> <span class="nc">CMonad</span><span class="o">(</span><span class="n">findUserByLogin</span><span class="o">(</span><span class="n">login</span><span class="o">))</span>
</span><span class="line">    <span class="n">address</span> <span class="k">&lt;-</span> <span class="nc">CMonad</span><span class="o">(</span><span class="n">findAddressByUserId</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="o">))</span>
</span><span class="line">  <span class="o">}</span> <span class="k">yield</span> <span class="n">address</span><span class="o">.</span><span class="n">street</span>
</span></code></pre></td></tr></table></div></figure>

<p>Of course it doesn’t work because we haven’t yet provided implementation for <code>flatMap</code> and <code>map</code></p>

<p>Let’s start with <code>flatMap</code>. To make things clear a little I introduced a new
method <code>flatMapF</code> and defined <code>flatMap</code> in terms of <code>flatMapF</code></p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">case</span> <span class="k">class</span> <span class="nc">CMonad</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line"> <span class="k">def</span> <span class="n">flatMapF</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">B</span><span class="o">]])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">G</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class="line">   <span class="o">???</span>
</span><span class="line">
</span><span class="line"> <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">G</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class="line">   <span class="n">flatMapF</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="n">value</span><span class="o">)</span>
</span><span class="line">
</span><span class="line"> <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span><span class="line">
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
<p>In order to apply <code>f : A =&gt; F[G[B]]</code> we need to extract <code>A</code> from <code>value: F[G[A]]</code></p>

<p>One attempt could end with following code</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">case</span> <span class="k">class</span> <span class="nc">CMonad</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line"> <span class="k">def</span> <span class="n">flatMapF</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">B</span><span class="o">]])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">G</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class="line">   <span class="nc">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span><span class="line">     <span class="n">F</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span>
</span><span class="line">       <span class="k">val</span> <span class="n">gb</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">G</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">ga</span><span class="o">)</span> <span class="o">{</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span>
</span><span class="line">         <span class="o">???</span>
</span><span class="line">       <span class="o">}</span>
</span><span class="line">       <span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">gb</span><span class="o">)</span>
</span><span class="line">     <span class="o">}</span>
</span><span class="line">   <span class="o">}</span>
</span><span class="line">
</span><span class="line"> <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">G</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class="line">   <span class="n">flatMapF</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="n">value</span><span class="o">)</span>
</span><span class="line">
</span><span class="line"> <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">ComposedMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span><span class="line">
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
<p>Now we can apply <code>f</code> with <code>A</code> and we will get <code>fgb : F[G[B]]</code></p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"> <span class="k">def</span> <span class="n">flatMapF</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">B</span><span class="o">]])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">G</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class="line">   <span class="nc">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span><span class="line">     <span class="n">F</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span>
</span><span class="line">       <span class="k">val</span> <span class="n">gb</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">G</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">ga</span><span class="o">)</span> <span class="o">{</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span>
</span><span class="line">         <span class="k">val</span> <span class="n">fgb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class="line">         <span class="o">???</span>
</span><span class="line">       <span class="o">}</span>
</span><span class="line">       <span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">gb</span><span class="o">)</span>
</span><span class="line">     <span class="o">}</span>
</span><span class="line">   <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
<p>In order to make compiler happy we need to take one step more - extract
<code>G[B]</code> from <code>F[G[B]]</code> and return that value from inner most <code>flatMap</code>.
This of course is not possible knowing only that <code>F</code> and <code>G</code> form a monad.</p>

<p>Another attempt can lead us to the code like</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"> <span class="k">def</span> <span class="n">flatMapF</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">B</span><span class="o">]])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">G</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class="line">   <span class="nc">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span><span class="line">     <span class="n">F</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span>
</span><span class="line">       <span class="k">val</span> <span class="n">gfgb</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">B</span><span class="o">]]]</span> <span class="k">=</span> <span class="n">G</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">ga</span><span class="o">)</span> <span class="o">{</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span>
</span><span class="line">         <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class="line">       <span class="o">}</span>
</span><span class="line">       <span class="o">???</span>
</span><span class="line">     <span class="o">}</span>
</span><span class="line">   <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
<p>And now we need to extract <code>F[G[B]]</code> from <code>G[F[G[B]]]</code>. This also is not possible
if we know nothing about internal representation of <code>G</code>.</p>

<p>All this leads us to the conclusion that we can’t write a monad transformer
if we know nothing, about the monads.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/12/18/monad-transformers-a-quick-recap/">Monad Transformers - a Quick Recap</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2018-12-18T23:19:06+01:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2018</span></span> <span class='time'>11:19 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Someone have said that <strong>monads</strong> are like burrito, if you ever taste one than
you can’t imagine live without it.</p>

<p><strong>Monads</strong> are a powerful tool. Thanks to them we can abstract over computation.
We can make one computation depended on another and if needed fail fast.</p>

<p>But one day the time will come when we have two different <strong>monads</strong> and we will find
out that they don’t compose !</p>

<p>Let’s make some code to visualize the problem. I am going to show two use
cases and I will start with the simplest one.</p>

<h3 id="case-1">Case 1</h3>
<p>We have two entities : <code>User</code> and <code>Address</code> and two functions retrieving data
with the respect of a given predicate</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">login</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span><span class="line"><span class="k">case</span> <span class="k">class</span> <span class="nc">Address</span><span class="o">(</span><span class="n">userId</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">street</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="n">findUserByLogin</span><span class="o">(</span><span class="n">login</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span><span class="line"><span class="k">def</span> <span class="n">findAddressByUserId</span><span class="o">(</span><span class="n">userId</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Address</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span></code></pre></td></tr></table></div></figure>
<p>Our goal is to write a function which for a given login returns user’s street name</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">def</span> <span class="n">findStreetByLogin</span><span class="o">(</span><span class="n">login</span> <span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
</span><span class="line">  <span class="k">for</span> <span class="o">{</span>
</span><span class="line">    <span class="n">user</span> <span class="k">&lt;-</span> <span class="n">findUserByLogin</span><span class="o">(</span><span class="n">login</span><span class="o">)</span>
</span><span class="line">    <span class="n">address</span> <span class="k">&lt;-</span> <span class="n">findAddressByUserId</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="o">)</span>
</span><span class="line">  <span class="o">}</span> <span class="k">yield</span> <span class="n">address</span><span class="o">.</span><span class="n">street</span>
</span></code></pre></td></tr></table></div></figure>

<p>So far so good - quite simple and classic enterprise task :)</p>

<p>However there are two caveats to this solution worth noting. What happened
if there is no such user or the user exists but it has no address ?
It is obvious that we will see <code>Null Pointer Exception</code> - sick !</p>

<p>Of course we can filter out those nulls and rewrite functions to be aware of
them but as you already know this is also not a good solution. Can we
do better ? Yes we can, let’s introduce a context aware
of whether value exists or not (<code>Option</code> data type).</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">def</span> <span class="n">findUserByLogin</span><span class="o">(</span><span class="n">login</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span> <span class="o">???</span>
</span><span class="line"><span class="k">def</span> <span class="n">findAddressByUserId</span><span class="o">(</span><span class="n">userId</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Address</span><span class="o">]]</span> <span class="k">=</span> <span class="o">???</span>
</span></code></pre></td></tr></table></div></figure>
<p>But wait below function is not compiling…</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">def</span> <span class="n">findStreetByLogin</span><span class="o">(</span><span class="n">login</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
</span><span class="line">  <span class="k">for</span> <span class="o">{</span>
</span><span class="line">    <span class="n">maybeUser</span> <span class="k">&lt;-</span> <span class="n">findUserByLogin</span><span class="o">(</span><span class="n">login</span><span class="o">)</span>
</span><span class="line">    <span class="n">user</span> <span class="k">&lt;-</span> <span class="n">maybeUser</span>
</span><span class="line">    <span class="n">address</span> <span class="k">&lt;-</span> <span class="n">findAddressByUserId</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="o">)</span>
</span><span class="line">  <span class="o">}</span> <span class="k">yield</span> <span class="n">address</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">street</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>
<p>It turns out that <code>Future</code> and <code>Option</code> <strong>monads</strong> do not compose in such a way.
For a first look, composition looks very natural in <code>for</code> comprehension,
but if we transform it into series of <code>flatMap</code> and <code>map</code> at the end, we
will notice that the puzzles don’t feet. If we start with <code>Future</code> than the
function passed to <code>flatMap</code> must return a <code>Future</code>. In our case we want
to return <code>Option</code> in the middle and based on it return a next <code>Future</code>
being a container fo an user’s possible address.</p>

<p>Equipped with this knowledge we can rewrite our function in the following
way</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">def</span> <span class="n">findStreetByLogin</span><span class="o">(</span><span class="n">login</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
</span><span class="line">  <span class="n">findUserByLogin</span><span class="o">(</span><span class="n">login</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span>
</span><span class="line">    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">findAddressByUserId</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">street</span><span class="o">))</span>
</span><span class="line">    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">.</span><span class="n">successful</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
</span><span class="line">  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
<p>Now it compiles and return correct results. But it is not as readable as
our first naive attempt. Can we do better ? Ideally we would want to have
something like</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">def</span> <span class="n">findStreetByLogin</span><span class="o">(</span><span class="n">login</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">???</span> <span class="o">=</span>
</span><span class="line">  <span class="k">for</span> <span class="o">{</span>
</span><span class="line">    <span class="n">user</span> <span class="k">&lt;-</span> <span class="o">???(</span><span class="n">findUserByLogin</span><span class="o">(</span><span class="n">login</span><span class="o">))</span>
</span><span class="line">    <span class="n">address</span> <span class="k">&lt;-</span> <span class="o">???(</span><span class="n">findAddressByUserId</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="o">))</span>
</span><span class="line">  <span class="o">}</span> <span class="k">yield</span> <span class="n">address</span><span class="o">.</span><span class="n">street</span>
</span></code></pre></td></tr></table></div></figure>
<p>We need somehow to fuse <code>Future</code> with <code>Option</code> in a smart way to make
the composition possible.</p>

<h4 id="fusing-future-with-option">Fusing <code>Future</code> with <code>Option</code></h4>
<p>We already know that <code>for</code> comprehension deals with <code>flatMap</code>, <code>map</code>,
<code>withFilter</code> and <code>foreach</code>. In our case compiler needs only <code>flaMap</code> and <code>map</code>
to de sugar <code>for</code>. So let’s introduce a new data type <code>OptionFuture</code>,
which wraps <code>Future[Option[A]]</code> and in a proper way handles
flatMap in order to compose <code>Future</code> with <code>Option</code>.</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">case</span> <span class="k">class</span> <span class="nc">OptionFuture</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">OptionFuture</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">OptionFuture</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class="line">    <span class="n">flatMapF</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="n">value</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">flatMapF</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]])</span>
</span><span class="line">                 <span class="o">(</span><span class="k">implicit</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">OptionFuture</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">OptionFuture</span><span class="o">(</span>
</span><span class="line">    <span class="n">value</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">as</span> <span class="k">=&gt;</span>
</span><span class="line">      <span class="n">as</span> <span class="k">match</span> <span class="o">{</span>
</span><span class="line">        <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class="line">        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">.</span><span class="n">successful</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
</span><span class="line">      <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">  <span class="o">)</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">OptionFuture</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class="line">    <span class="nc">OptionFuture</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">})</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
<p>Take a little time to better look at <code>OptionFuture</code> data type.
First question coming to my mind is - can we make it more abstract ?
It turns out that we can abstract over <code>Future</code> very easly. In terms
of <code>Future</code> we are calling only two kinds of functions:</p>

<ul>
  <li><code>flatMap</code></li>
  <li><code>Future.successful</code></li>
</ul>

<p>It means that <code>Future</code> can be swapped with <code>Monad</code>.</p>

<p>What about the <code>Option</code> ? Over the <code>Option</code> we are performing <strong>pattern matching</strong>
- so it means that we need to know something about it structure.</p>

<p>And because of that we can’t to abstract over it.</p>

<p>This leads us to the definition of <strong>monad transformer</strong> for <code>Option</code> and
we call it <code>OptionT</code></p>

<h4 id="monad-transformer-for-option">Monad transformer for <code>Option</code></h4>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">case</span> <span class="k">class</span> <span class="nc">OptionT</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">OptionT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">B</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">OptionT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class="line">    <span class="n">flatMapF</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="n">value</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">flatMapF</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">OptionT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">OptionT</span><span class="o">(</span>
</span><span class="line">    <span class="n">F</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="n">as</span> <span class="k">=&gt;</span>
</span><span class="line">      <span class="n">as</span> <span class="k">match</span> <span class="o">{</span>
</span><span class="line">        <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class="line">        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
</span><span class="line">      <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">  <span class="o">)</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">OptionT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class="line">    <span class="nc">OptionT</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">})</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
<p><code>OptionT[F[_], A]</code> abstracts over <code>F</code> and <code>A</code> and it only requires that <code>F</code>
is a monad. The name of the <strong>monad transformer</strong> comes from the fact that,
in order to implement this wrapper, we need to know what the inner
most monad in the stack is - in this case <code>Option</code>. Without this knowledge
we can’t compose any two given monads with itself.</p>

<h4 id="monad-quick-recap">Monad quick recap</h4>
<p>A minimal api for monad can be described by following trait</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">trait</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">M</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">flatMap</span><span class="o">(</span><span class="n">xs</span><span class="o">)(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">pure</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span>
</span><span class="line">
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="k">object</span> <span class="nc">Monad</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">M</span><span class="o">])</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">M</span><span class="o">]</span> <span class="k">=</span> <span class="n">m</span>
</span><span class="line">
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
<p>And its instance for <code>Future</code> you can find below.</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">object</span> <span class="nc">MonadInstances</span> <span class="o">{</span>
</span><span class="line">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">futureInstance</span><span class="o">(</span><span class="k">implicit</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">Future</span><span class="o">]</span> <span class="k">=</span>
</span><span class="line">    <span class="k">new</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">Future</span><span class="o">]</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">      <span class="k">override</span> <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Future</span><span class="o">.</span><span class="n">successful</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">      <span class="k">override</span> <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">f</span><span class="o">)(</span><span class="n">ex</span><span class="o">)</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

<h4 id="a-solution">A solution</h4>
<p>Putting all pieces together we can finally write</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext.Implicits.global</span>
</span><span class="line"><span class="k">import</span> <span class="nn">MonadInstances._</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="n">findStreetByLogin</span><span class="o">(</span><span class="n">login</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">OptionT</span><span class="o">[</span><span class="kt">Future</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
</span><span class="line">  <span class="k">for</span> <span class="o">{</span>
</span><span class="line">    <span class="n">user</span> <span class="k">&lt;-</span> <span class="nc">OptionT</span><span class="o">(</span><span class="n">findUserByLogin</span><span class="o">(</span><span class="n">login</span><span class="o">))</span>
</span><span class="line">    <span class="n">address</span> <span class="k">&lt;-</span> <span class="nc">OptionT</span><span class="o">(</span><span class="n">findAddressByUserId</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="o">))</span>
</span><span class="line">  <span class="o">}</span> <span class="k">yield</span> <span class="n">address</span><span class="o">.</span><span class="n">street</span>
</span></code></pre></td></tr></table></div></figure>
<p>of course we can return directly <code>Future[Option[String]]</code> just by calling
<code>value</code> function on the result like</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">def</span> <span class="n">findStreetByLogin</span><span class="o">(</span><span class="n">login</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
</span><span class="line">  <span class="o">(</span><span class="k">for</span> <span class="o">{</span>
</span><span class="line">    <span class="n">user</span> <span class="k">&lt;-</span> <span class="nc">OptionT</span><span class="o">(</span><span class="n">findUserByLogin</span><span class="o">(</span><span class="n">login</span><span class="o">))</span>
</span><span class="line">    <span class="n">address</span> <span class="k">&lt;-</span> <span class="nc">OptionT</span><span class="o">(</span><span class="n">findAddressByUserId</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="o">))</span>
</span><span class="line">  <span class="o">}</span> <span class="k">yield</span> <span class="n">address</span><span class="o">.</span><span class="n">street</span><span class="o">).</span><span class="n">value</span>
</span></code></pre></td></tr></table></div></figure>
<p>`
and that’s it.</p>

<h4 id="final-word">Final word</h4>

<p>At the beginning I said that I have two cases to show, but because the
post could be to long to go through without a brake I decided to split it
into two pieces. The whole code base used in this post can be found in
the following <a href="https://github.com/ssledz/ssledz.github.io-src/tree/master/monad-transformer">link</a></p>

<p>More in <a href="/blog/2019/01/24/monad-transformers-part-2/">part 2</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/12/05/genetle-fp-intro/">Gentle Introduction to Functional Programming - Live Coding Session</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2018-12-05T22:33:42+02:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2018</span></span> <span class='time'>10:33 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Slides for Lunch2Learn (L2L) session are available <a href="/presentations/gentle-fp-intro.html">here</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/10/25/recursion-a-quick-introduction/">Recursion - a Quick Introduction</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-10-25T02:33:42+02:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>2:33 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Slides for Lunch2Learn (L2L) session are available <a href="/presentations/recursion.html">here</a>.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2021/01/13/recursive-tail-call-optimization-and-trampoline/">Recursive Tail Call Optimization and Trampoline</a>
      </li>
    
      <li class="post">
        <a href="/blog/2020/09/23/object-oriented-programming-vs-functional-programming/">Object Oriented Programming vs Functional Programming</a>
      </li>
    
      <li class="post">
        <a href="/blog/2020/04/26/static-linking-with-ghc/">Static Linking With Ghc</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/03/10/option-monad-from-scratch/">Option Monad - From Scratch</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/02/17/monads-lunch2learn-session/">Monads - Lunch2Learn Session</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Category Cloud</h1>
    <span id="tag-cloud"><a href='/blog/categories/algorithms' style='font-size: 124.0%'>algorithms(4)</a> <a href='/blog/categories/automata' style='font-size: 106.0%'>automata(1)</a> <a href='/blog/categories/bash' style='font-size: 112.0%'>bash(2)</a> <a href='/blog/categories/certification' style='font-size: 112.0%'>certification(2)</a> <a href='/blog/categories/context-free-grammar' style='font-size: 106.0%'>context free grammar(1)</a> <a href='/blog/categories/coursera' style='font-size: 106.0%'>coursera(1)</a> <a href='/blog/categories/dynamic-programming' style='font-size: 106.0%'>dynamic programming(1)</a> <a href='/blog/categories/functional-programming' style='font-size: 160.0%'>functional-programming(10)</a> <a href='/blog/categories/ghc' style='font-size: 106.0%'>ghc(1)</a> <a href='/blog/categories/git' style='font-size: 106.0%'>git(1)</a> <a href='/blog/categories/git-svn' style='font-size: 106.0%'>git-svn(1)</a> <a href='/blog/categories/github' style='font-size: 106.0%'>github(1)</a> <a href='/blog/categories/haskell' style='font-size: 106.0%'>haskell(1)</a> <a href='/blog/categories/hotswap' style='font-size: 106.0%'>hotswap(1)</a> <a href='/blog/categories/java' style='font-size: 148.0%'>java(8)</a> <a href='/blog/categories/jvm' style='font-size: 106.0%'>jvm(1)</a> <a href='/blog/categories/kata' style='font-size: 106.0%'>kata(1)</a> <a href='/blog/categories/l2l' style='font-size: 124.0%'>l2l(4)</a> <a href='/blog/categories/learning' style='font-size: 124.0%'>learning(4)</a> <a href='/blog/categories/linux' style='font-size: 124.0%'>linux(4)</a> <a href='/blog/categories/mac' style='font-size: 106.0%'>mac(1)</a> <a href='/blog/categories/monad-transformers' style='font-size: 112.0%'>monad-transformers(2)</a> <a href='/blog/categories/monads' style='font-size: 130.0%'>monads(5)</a> <a href='/blog/categories/nas' style='font-size: 106.0%'>nas(1)</a> <a href='/blog/categories/octopress' style='font-size: 106.0%'>octopress(1)</a> <a href='/blog/categories/oracle' style='font-size: 112.0%'>oracle(2)</a> <a href='/blog/categories/pattern' style='font-size: 106.0%'>pattern(1)</a> <a href='/blog/categories/productivity' style='font-size: 106.0%'>productivity(1)</a> <a href='/blog/categories/puzzle' style='font-size: 130.0%'>puzzle(5)</a> <a href='/blog/categories/recursion' style='font-size: 136.0%'>recursion(6)</a> <a href='/blog/categories/review' style='font-size: 118.0%'>review(3)</a> <a href='/blog/categories/scala' style='font-size: 154.0%'>scala(9)</a> <a href='/blog/categories/spark' style='font-size: 106.0%'>spark(1)</a> <a href='/blog/categories/svn' style='font-size: 106.0%'>svn(1)</a> <a href='/blog/categories/tmux' style='font-size: 106.0%'>tmux(1)</a> <a href='/blog/categories/vagrant' style='font-size: 106.0%'>vagrant(1)</a> <a href='/blog/categories/vim' style='font-size: 106.0%'>vim(1)</a> <a href='/blog/categories/virtual-box' style='font-size: 112.0%'>virtual box(2)</a> <a href='/blog/categories/virtualization' style='font-size: 112.0%'>virtualization(2)</a> </span>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/ssledz">@ssledz</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'ssledz',
            count: 10,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>

<section>
  <h1>About Me</h1>
  <p>Sławomir Śledź, Senior Scala/Java Developer at <a target="_blank" href="https://www.cloudtechnologies.pl/">Cloud Technologies S.A.</a></p>
</section>

<section>
	<span>
		<img src="http://www.gravatar.com/avatar/ccd7a764d62ec150d1a6c48518835736" alt="Gravatar of Sławomir Śledź " title="Gravatar of Sławomir Śledź" />
	</span>
</section>

<section>
<h1>Stack Overflow</h1>
<a href="http://stackoverflow.com/users/3726554/slavik" target="_blank">
<img src="http://stackoverflow.com/users/flair/3726554.png?theme=clean" width="208" height="58" alt="profile for slavik at Stack Overflow, Q&amp;A for professional and enthusiast programmers" title="profile for slavik at Stack Overflow, Q&amp;A for professional and enthusiast programmers">
</a>
</section>


<section>
    <h1>Certificates</h1>
    <div data-iframe-width="250" data-iframe-height="270" data-share-badge-id="58fa8011-f1da-4a68-846c-b869ee04012b"></div>
    <div data-iframe-width="250" data-iframe-height="270" data-share-badge-id="d5492e6e-9cb6-4665-b131-973bf8204190"></div>
    <script type="text/javascript">
        (function() {
            var s = document.createElement('script');
            s.type = 'text/javascript';
            s.async = true;
            s.src = '//www.youracclaim.com/assets/utilities/embed.js';
            var o = document.getElementsByTagName('script')[0];
            o.parentNode.insertBefore(s, o);
        })();
    </script>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2021 - Sławomir Śledź -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'ssledz';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>





  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>

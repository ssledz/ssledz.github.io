<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scala | My Programmer's Road]]></title>
  <link href="http://ssledz.github.io/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://ssledz.github.io/"/>
  <updated>2019-03-05T17:12:59+01:00</updated>
  <id>http://ssledz.github.io/</id>
  <author>
    <name><![CDATA[Sławomir Śledź]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Monads - Lunch2Learn Session]]></title>
    <link href="http://ssledz.github.io/blog/2019/02/17/monads-lunch2learn-session/"/>
    <updated>2019-02-17T13:33:47+01:00</updated>
    <id>http://ssledz.github.io/blog/2019/02/17/monads-lunch2learn-session</id>
    <content type="html"><![CDATA[<p>Slides for Lunch2Learn (L2L) session are available <a href="/presentations/monads-intro.html">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[About Monads - a Gentle Introduction]]></title>
    <link href="http://ssledz.github.io/blog/2019/01/28/about-monads-a-gentle-introduction/"/>
    <updated>2019-01-28T00:23:36+01:00</updated>
    <id>http://ssledz.github.io/blog/2019/01/28/about-monads-a-gentle-introduction</id>
    <content type="html"><![CDATA[<p>In functional programming monad is a design pattern which is used to
express how states of computations are changing. It can take a form of some
abstract data type constructor with two abstract functions.</p>

<p>In <code>scala</code> we can define this contract using <code>Monad</code> type class
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="n">pure</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;x: A&quot;</span><span class="o">&gt;</span><span class="n">A</span><span class="o">&lt;/</span><span class="n">a</span><span class="k">&gt;:</span> <span class="n">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="n">flatMap</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;xs: M[A]&quot;</span><span class="o">&gt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">M</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">B</span><span class="o">]&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;xs: M[A]&quot;</span><span class="o">&gt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">flatMap</span><span class="o">(</span><span class="n">xs</span><span class="o">)(</span><span class="n">x</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">pure</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)))&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Functions <code>pure</code> and <code>flatMap</code> for a given monad <code>M[_]</code> have to follow
some laws - I will talk about them later.</p>

<p>Function <code>map</code> can be defined
in terms of <code>flatMap</code> and <code>pure</code> and this is a bonus which we get for a free
when we provide an instance of a Monad for a type <code>M[_]</code>.</p>

<p>We can think about <code>M[A]</code> like about some smart container
for a value (values) of type <code>A</code>. This container abstracts away from how this value
is kept. We can have many flavors of them like container:</p>

<ul>
  <li>aware of whether or not the value exists</li>
  <li>with more then one value</li>
  <li>for which getting the value would trigger some kind of <code>IO</code> operation</li>
  <li>with value which eventually could appear in future</li>
  <li>with value or error</li>
  <li>with value dependent on some kind of state</li>
  <li>with value and some logging information</li>
  <li>etc</li>
</ul>

<p>Monad let us focus on what we want to do with the contained value. It is
like a context in which the value exists. When we want to do some computation
we are abstracting over the context so we aren’t disrupted whether or
not the value exists, we have many of them or the value may appear in a future.
We want just to get the value out of the container for a moment to make
some computation and then put it again. The context is important only when
we want to pull out a value permanently.</p>

<p>Another advantage of the monad is an ability of sequencing the computations.
Having let’s say two computations we can very easily make dependence
between them saying that the computations of the second depends on
a result of the first. Of course this can be scaled to more than two.</p>

<p>At first glance, it may seem to be not so impressive because it is
very common to make such things during coding. But be aware that monad
frees us from thinking about the context in which the value exists. The context
can be for example an asynchronous computation. Dealing with concurrency
is challenging - we have to be very careful to not make a hard to spot mistake.
Monad takes care about this complexity, providing a result of the
first computation as soon as possible giving us possibility to
spawn another computation in asynchronous manner.</p>

<h3 id="laws">Laws</h3>
<p>Each monad needs to follow three laws</p>

<ul>
  <li>Left identity: <code>return a &gt;&gt;= f ≡ f a</code></li>
  <li>Right identity: <code>m &gt;&gt;= return ≡ m</code></li>
  <li>Associativity: <code>(m &gt;&gt;= f) &gt;&gt;= g ≡ m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code></li>
</ul>

<p>These laws was taken from haskell because expressions there are very compact and
easy to follow. Function <code>&gt;&gt;=</code> in scala maps to <code>flatMap</code>, <code>return</code> is
just a <code>pure</code>, <code>f x</code> is an application of function <code>f</code> with <code>x</code> and the
last one <code>\x -&gt; ...</code> is a lambda expression.</p>

<p>Laws in scala can be written in a following way (using ScalaCheck)
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">monad</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">Monad</span><span class="o">[</span><span class="kt">M</span><span class="o">]]&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">property</span><span class="o">(</span><span class="err">“</span><span class="nc">Left</span> <span class="n">identity</span><span class="k">:</span> <span class="kt">return</span> <span class="kt">a</span><span class="err"> »</span><span class="o">=</span> <span class="n">f</span> <span class="o">≡</span> <span class="n">f</span> <span class="n">a</span><span class="err">”</span><span class="o">)</span> <span class="k">=</span> <span class="n">forAll</span> <span class="o">{</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">M</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>  <span class="o">(&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">return</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;(</span><span class="n">a</span><span class="o">)</span><span class="err"> »</span><span class="k">=</span> <span class="n">f</span><span class="o">)</span> <span class="o">===</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'><span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">property</span><span class="o">(</span><span class="err">“</span><span class="nc">Right</span> <span class="n">identity</span><span class="k">:</span> <span class="kt">m</span><span class="err"> »</span><span class="o">=</span> <span class="k">return</span> <span class="o">≡</span> <span class="n">m</span><span class="err">”</span><span class="o">)</span> <span class="k">=</span> <span class="n">forAll</span> <span class="o">{</span> <span class="n">m</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>  <span class="o">(</span><span class="n">m</span><span class="err"> »</span><span class="k">=</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">return</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;)</span> <span class="o">===</span> <span class="n">m</span>
</span><span class='line'><span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">property</span><span class="o">(</span><span class="err">“</span><span class="nc">Associativity</span><span class="k">:</span> <span class="o">(</span><span class="kt">m</span><span class="err"> »</span><span class="o">=</span> <span class="kt">f</span><span class="o">)</span><span class="err"> »</span><span class="k">=</span> <span class="n">g</span> <span class="o">≡</span> <span class="n">m</span><span class="err"> »</span><span class="k">=</span> <span class="o">(\</span><span class="n">x</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">f</span> <span class="n">x</span><span class="err"> »</span><span class="k">=</span> <span class="n">g</span><span class="o">)</span><span class="err">”</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">forAll</span> <span class="o">{</span> <span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">M</span><span class="o">[</span><span class="kt">B</span><span class="o">],</span> <span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">M</span><span class="o">[</span><span class="kt">C</span><span class="o">])</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>    <span class="o">((</span><span class="n">m</span><span class="err"> »</span><span class="k">=</span> <span class="n">f</span><span class="o">)</span><span class="err"> »</span><span class="k">=</span> <span class="n">g</span><span class="o">)</span> <span class="o">===</span> <span class="o">(</span><span class="n">m</span><span class="err"> »</span><span class="k">=</span> <span class="o">(</span><span class="n">x</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="err"> »</span><span class="k">=</span> <span class="n">g</span><span class="o">))</span>
</span><span class='line'><span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">return</span><span class="o">&lt;/</span><span class="n">code</span><span class="k">&gt;:</span> <span class="n">A</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">monad</span><span class="o">.</span><span class="n">pure</span> <span class="k">_</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">private</span> <span class="k">implicit</span> <span class="k">class</span> <span class="nc">MonadOps</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;m: M[A]&quot;</span><span class="o">&gt;</span><span class="n">A</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span><span class="err"> »</span><span class="o">=&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;f: A =&amp;gt; M[B]&quot;</span><span class="o">&gt;</span><span class="n">B</span><span class="o">&lt;/</span><span class="n">a</span><span class="k">&gt;:</span> <span class="n">M</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">monad</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">m</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
If you are curious about implementation details take a look on this <a href="https://raw.githubusercontent.com/ssledz/ssledz.github.io-src/master/monad-gentle-introduction/src/test/scala/monad/intro/AbstractMonadProperties.scala">class</a></p>

<h3 id="flavors-of-monads">Flavors of monads</h3>

<p>This section is a placeholder for a list of posts about monads mentioned in
this article. I will try my best to deliver a missing content. Watch my blog
for an update.</p>

<p>Monads:</p>

<ul>
  <li>Option</li>
  <li>Either</li>
  <li>Id</li>
  <li>Writer</li>
  <li>Reader</li>
  <li>State</li>
  <li>Try</li>
  <li>IO</li>
  <li>List</li>
</ul>

<h3 id="resources">Resources</h3>

<ul>
  <li><a href="https://www.quora.com/What-are-monads-in-functional-programming-and-why-are-they-useful-Are-they-a-generic-solution-to-the-problem-of-state-in-FP-or-Haskell-specific-Are-they-specific-to-Haskell-or-are-they-encountered-in-other-FP-languages">What are monads in functional programming and why are they useful?</a></li>
  <li><a href="http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html">You Could Have Invented Monads!</a></li>
  <li><a href="https://dev.to/theodesp/explain-monads-like-im-five">Explain Monads Like I’m five</a></li>
  <li><a href="https://wiki.haskell.org/All_About_Monads">All About Monads</a></li>
  <li><a href="https://www.haskell.org/tutorial/monads.html">A Gentle Introduction to Haskell</a></li>
  <li><a href="http://learnyouahaskell.com/a-fistful-of-monads">A Fistful of Monads</a></li>
  <li><a href="https://github.com/ssledz/ssledz.github.io-src/tree/master/monad-gentle-introduction">Sources to the post</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Monad Transformers - Part 2]]></title>
    <link href="http://ssledz.github.io/blog/2019/01/24/monad-transformers-part-2/"/>
    <updated>2019-01-24T21:46:06+01:00</updated>
    <id>http://ssledz.github.io/blog/2019/01/24/monad-transformers-part-2</id>
    <content type="html"><![CDATA[<p>In a previous <a href="/blog/2018/12/18/monad-transformers-a-quick-recap/">post</a>
I introduced monad transformers and since now we should have a good feeling
about their usage and how they can be helpful.</p>

<p>Designing a monad transformer we decided to fix inner most monad. This
decision was dictated by the fact that we couldn’t replace code dependent
on internal representation of that inner most monad. I think that this step
could not be as obvious as I expected to be. And now I will try to
make it more clear.</p>

<p>Let’s try to bite the problem from different side. Assume that we can write
a monad transformer and know nothing about monads internal representation.
Let’s call it <code>CMonad</code> (shorthand from <code>ComposedMonad</code>).</p>

<p>Such a class could look like
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">CMonad</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;value: F[G[A]]&quot;</span><span class="o">&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">&lt;em&gt;</span><span class="o">],</span> <span class="n">G</span><span class="o">[</span><span class="kt">&lt;/em&gt;</span><span class="o">],</span> <span class="n">A</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="n">flatMap</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;f: A =&amp;gt; CMonad[F, G, B]&quot;</span><span class="o">&gt;</span><span class="n">B</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">G</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>   <span class="o">???&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;f: A =&amp;gt; B&quot;</span><span class="o">&gt;</span><span class="n">B</span><span class="o">&lt;/</span><span class="n">a</span><span class="k">&gt;:</span> <span class="nc">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">???&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure>
Here <code>F[_]</code> and <code>G[_]</code> are higher kinded type representing outer and inner most monad.</p>

<p>Then a problem introduced in a previous post could be solved following
<code>scala
def findStreetByLogin(login: String): CMonad[Future, Option, String] =
  for {
    user &lt;- CMonad(findUserByLogin(login))
    address &lt;- CMonad(findAddressByUserId(user.id))
  } yield address.street
</code></p>

<p>Of course it doesn’t work because we haven’t yet provided implementation for <code>flatMap</code> and <code>map</code></p>

<p>Let’s start with <code>flatMap</code>. To make things clear a little I introduced a new
method <code>flatMapF</code> and defined <code>flatMap</code> in terms of <code>flatMapF</code>
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">CMonad</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;value: F[G[A]]&quot;</span><span class="o">&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">&lt;em&gt;</span><span class="o">],</span> <span class="n">G</span><span class="o">[</span><span class="kt">&lt;/em&gt;</span><span class="o">],</span> <span class="n">A</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="n">flatMapF</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;f: A =&amp;gt; F[G[B]]&quot;</span><span class="o">&gt;</span><span class="n">B</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">G</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>   <span class="o">???&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="n">flatMap</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;f: A =&amp;gt; CMonad[F, G, B]&quot;</span><span class="o">&gt;</span><span class="n">B</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">G</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>   <span class="n">flatMapF</span><span class="o">(</span><span class="n">a</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="n">value</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;f: A =&amp;gt; B&quot;</span><span class="o">&gt;</span><span class="n">B</span><span class="o">&lt;/</span><span class="n">a</span><span class="k">&gt;:</span> <span class="nc">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">???&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure>
In order to apply <code>f : A =&gt; F[G[B]]</code> we need to extract <code>A</code> from <code>value: F[G[A]]</code></p>

<p>One attempt could end with following code
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">CMonad</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;value: F[G[A]]&quot;</span><span class="o">&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">&lt;em&gt;</span><span class="o">],</span> <span class="n">G</span><span class="o">[</span><span class="kt">&lt;/em&gt;</span><span class="o">],</span> <span class="n">A</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="n">flatMapF</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;f: A =&amp;gt; F[G[B]]&quot;</span><span class="o">&gt;</span><span class="n">B</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">G</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>   <span class="nc">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>     <span class="n">F</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>       <span class="k">val</span> <span class="n">gb</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">G</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">ga</span><span class="o">)</span> <span class="o">{</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>         <span class="o">???</span>
</span><span class='line'>       <span class="o">}</span>
</span><span class='line'>       <span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">gb</span><span class="o">)</span>
</span><span class='line'>     <span class="o">}</span>
</span><span class='line'>   <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="n">flatMap</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;f: A =&amp;gt; CMonad[F, G, B]&quot;</span><span class="o">&gt;</span><span class="n">B</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">G</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>   <span class="n">flatMapF</span><span class="o">(</span><span class="n">a</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="n">value</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;f: A =&amp;gt; B&quot;</span><span class="o">&gt;</span><span class="n">B</span><span class="o">&lt;/</span><span class="n">a</span><span class="k">&gt;:</span> <span class="nc">ComposedMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">???&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="nc">Now</span> <span class="n">we</span> <span class="n">can</span> <span class="n">apply</span> <span class="n">`f`</span> <span class="k">with</span> <span class="n">`A`</span> <span class="n">and</span> <span class="n">we</span> <span class="n">will</span> <span class="n">get</span> <span class="n">`fgb : F[G[B]]`</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">scala</span>
</span><span class='line'> <span class="k">def</span> <span class="n">flatMapF</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;f: A =&amp;gt; F[G[B]]&quot;</span><span class="o">&gt;</span><span class="n">B</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">G</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>   <span class="nc">CMonad</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>     <span class="n">F</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>       <span class="k">val</span> <span class="n">gb</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">G</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">ga</span><span class="o">)</span> <span class="o">{</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>         <span class="k">val</span> <span class="n">fgb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>         <span class="o">???</span>
</span><span class='line'>       <span class="o">}</span>
</span><span class='line'>       <span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">gb</span><span class="o">)</span>
</span><span class='line'>     <span class="o">}</span>
</span><span class='line'>   <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
In order to make compiler happy we need to take one step more - extract
<code>G[B]</code> from <code>F[G[B]]</code> and return that value from inner most <code>flatMap</code>.
This of course is not possible knowing only that <code>F</code> and <code>G</code> form a monad.</p>

<p>Another attempt can lead us to the code like
<code>scala
 def flatMapF[B](f: A =&gt; F[G[B]])(implicit F: Monad[F], G: Monad[G]): CMonad[F, G, B] =
   CMonad[F, G, B] {
     F.flatMap(value) { ga: G[A] =&gt;
       val gfgb: G[F[G[B]]] = G.map(ga) { a: A =&gt;
         f(a)
       }
       ???
     }
   }
</code>
And now we need to extract <code>F[G[B]]</code> from <code>G[F[G[B]]]</code>. This also is not possible
if we know nothing about internal representation of <code>G</code>.</p>

<p>All this leads us to the conclusion that we can’t write a monad transformer
if we know nothing, about the monads.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Monad Transformers - a Quick Recap]]></title>
    <link href="http://ssledz.github.io/blog/2018/12/18/monad-transformers-a-quick-recap/"/>
    <updated>2018-12-18T23:19:06+01:00</updated>
    <id>http://ssledz.github.io/blog/2018/12/18/monad-transformers-a-quick-recap</id>
    <content type="html"><![CDATA[<p>Someone have said that <strong>monads</strong> are like burrito, if you ever taste one than
you can’t imagine live without it.</p>

<p><strong>Monads</strong> are a powerful tool. Thanks to them we can abstract over computation.
We can make one computation depended on another and if needed fail fast.</p>

<p>But one day the time will come when we have two different <strong>monads</strong> and we will find
out that they don’t compose !</p>

<p>Let’s make some code to visualize the problem. I am going to show two use
cases and I will start with the simplest one.</p>

<h3 id="case-1">Case 1</h3>
<p>We have two entities : <code>User</code> and <code>Address</code> and two functions retrieving data
with the respect of a given predicate
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">login</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Address</span><span class="o">(</span><span class="n">userId</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">street</span><span class="k">:</span> <span class="kt">String</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="n">findUserByLogin</span><span class="o">(</span><span class="n">login</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span><span class='line'><span class="k">def</span> <span class="n">findAddressByUserId</span><span class="o">(</span><span class="n">userId</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Address</span><span class="o">]</span> <span class="k">=</span> <span class="o">???&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="nc">Our</span> <span class="n">goal</span> <span class="n">is</span> <span class="n">to</span> <span class="n">write</span> <span class="n">a</span> <span class="n">function</span> <span class="n">which</span> <span class="k">for</span> <span class="n">a</span> <span class="n">given</span> <span class="n">login</span> <span class="n">returns</span> <span class="n">user</span><span class="-Symbol">&#39;s</span> <span class="n">street</span> <span class="n">name</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">scala</span>
</span><span class='line'><span class="k">def</span> <span class="n">findStreetByLogin</span><span class="o">(</span><span class="n">login</span> <span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">user</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">findUserByLogin</span><span class="o">(</span><span class="n">login</span><span class="o">)</span>
</span><span class='line'>    <span class="n">address</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">findAddressByUserId</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">yield</span> <span class="n">address</span><span class="o">.</span><span class="n">street</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>So far so good - quite simple and classic enterprise task :)</p>

<p>However there are two caveats to this solution worth noting. What happened
if there is no such user or the user exists but it has no address ?
It is obvious that we will see <code>Null Pointer Exception</code> - sick !</p>

<p>Of course we can filter out those nulls and rewrite functions to be aware of
them but as you already know this is also not a good solution. Can we
do better ? Yes we can, let’s introduce a context aware
of whether value exists or not (<code>Option</code> data type).
<code>scala
def findUserByLogin(login: String): Future[Option[User]] = ???
def findAddressByUserId(userId: Long): Future[Option[Address]] = ???
</code>
But wait below function is not compiling…
<code>scala
def findStreetByLogin(login: String): Future[Option[String]] =
  for {
    maybeUser &lt;- findUserByLogin(login)
    user &lt;- maybeUser
    address &lt;- findAddressByUserId(user.id)
  } yield address.map(_.street)
</code>
It turns out that <code>Future</code> and <code>Option</code> <strong>monads</strong> do not compose in such a way.
For a first look, composition looks very natural in <code>for</code> comprehension,
but if we transform it into series of <code>flatMap</code> and <code>map</code> at the end, we
will notice that the puzzles don’t feet. If we start with <code>Future</code> than the
function passed to <code>flatMap</code> must return a <code>Future</code>. In our case we want
to return <code>Option</code> in the middle and based on it return a next <code>Future</code>
being a container fo an user’s possible address.</p>

<p>Equipped with this knowledge we can rewrite our function in the following
way
<code>scala
def findStreetByLogin(login: String): Future[Option[String]] =
  findUserByLogin(login).flatMap {
    case Some(user) =&gt; findAddressByUserId(user.id).map(_.map(_.street))
    case None =&gt; Future.successful(None)
  }
</code>
Now it compiles and return correct results. But it is not as readable as
our first naive attempt. Can we do better ? Ideally we would want to have
something like
<code>scala
def findStreetByLogin(login: String): ??? =
  for {
    user &lt;- ???(findUserByLogin(login))
    address &lt;- ???(findAddressByUserId(user.id))
  } yield address.street
</code>
We need somehow to fuse <code>Future</code> with <code>Option</code> in a smart way to make
the composition possible.</p>

<h4 id="fusing-future-with-option">Fusing <code>Future</code> with <code>Option</code></h4>
<p>We already know that <code>for</code> comprehension deals with <code>flatMap</code>, <code>map</code>,
<code>withFilter</code> and <code>foreach</code>. In our case compiler needs only <code>flaMap</code> and <code>map</code>
to de sugar <code>for</code>. So let’s introduce a new data type <code>OptionFuture</code>,
which wraps <code>Future[Option[A]]</code> and in a proper way handles
flatMap in order to compose <code>Future</code> with <code>Option</code>.
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">OptionFuture</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;value: Future[Option[A]]&quot;</span><span class="o">&gt;</span><span class="n">A</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="n">flatMap</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;f: A =&amp;gt; OptionFuture[B]&quot;</span><span class="o">&gt;</span><span class="n">B</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;(</span><span class="k">implicit</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">OptionFuture</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">flatMapF</span><span class="o">(</span><span class="n">a</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="n">value</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="n">flatMapF</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;f: A =&amp;gt; Future[Option[B]]&quot;</span><span class="o">&gt;</span><span class="n">B</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'>                 <span class="o">(</span><span class="k">implicit</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">OptionFuture</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">OptionFuture</span><span class="o">(</span>
</span><span class='line'>    <span class="n">value</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">as</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>      <span class="n">as</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>        <span class="k">case</span> <span class="k">_</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="nc">Future</span><span class="o">.</span><span class="n">successful</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;f: A =&amp;gt; B&quot;</span><span class="o">&gt;</span><span class="n">B</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;(</span><span class="k">implicit</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">OptionFuture</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">OptionFuture</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">x</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">x</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">})</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
Take a little time to better look at <code>OptionFuture</code> data type.
First question coming to my mind is - can we make it more abstract ?
It turns out that we can abstract over <code>Future</code> very easly. In terms
of <code>Future</code> we are calling only two kinds of functions:</p>

<ul>
  <li><code>flatMap</code></li>
  <li><code>Future.successful</code></li>
</ul>

<p>It means that <code>Future</code> can be swapped with <code>Monad</code>.</p>

<p>What about the <code>Option</code> ? Over the <code>Option</code> we are performing <strong>pattern matching</strong>
- so it means that we need to know something about it structure.</p>

<p>And because of that we can’t to abstract over it.</p>

<p>This leads us to the definition of <strong>monad transformer</strong> for <code>Option</code> and
we call it <code>OptionT</code></p>

<h4 id="monad-transformer-for-option">Monad transformer for <code>Option</code></h4>
<p>```scala
case class OptionT<a href="value: F[Option[A]]">F[_], A</a> {</p>

<p>def flatMap<a href="f: A =&gt; OptionT[F, B]">B</a>(implicit m: Monad[F]): OptionT[F, B] =
    flatMapF(a =&gt; f(a).value)</p>

<p>def flatMapF<a href="f: A =&gt; F[Option[B]]">B</a>(implicit F: Monad[F]): OptionT[F, B] = OptionT(
    F.flatMap(value) { as =&gt;
      as match {
        case Some(a) =&gt; f(a)
        case _ =&gt; F.pure(None)
      }
    }
  )</p>

<p>def map<a href="f: A =&gt; B">B</a>(implicit F: Monad[F]): OptionT[F, B] =
    OptionT(F.map(value) { x =&gt; x.map(f) })
}
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nc">OptionT</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]&lt;/</span><span class="n">code</span><span class="o">&gt;</span> <span class="n">abstracts</span> <span class="n">over</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">F</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span> <span class="n">and</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">A</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span> <span class="n">and</span> <span class="n">it</span> <span class="n">only</span> <span class="k">requires</span> <span class="n">that</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">F</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">is</span> <span class="n">a</span> <span class="n">monad</span><span class="o">.</span> <span class="nc">The</span> <span class="n">name</span> <span class="n">of</span> <span class="n">the</span> <span class="o">&lt;</span><span class="n">strong</span><span class="o">&gt;</span><span class="n">monad</span> <span class="n">transformer</span><span class="o">&lt;/</span><span class="n">strong</span><span class="o">&gt;</span> <span class="n">comes</span> <span class="n">from</span> <span class="n">the</span> <span class="n">fact</span> <span class="n">that</span><span class="o">,</span>
</span><span class='line'><span class="n">in</span> <span class="n">order</span> <span class="n">to</span> <span class="n">implement</span> <span class="k">this</span> <span class="n">wrapper</span><span class="o">,</span> <span class="n">we</span> <span class="n">need</span> <span class="n">to</span> <span class="n">know</span> <span class="n">what</span> <span class="n">the</span> <span class="n">inner</span>
</span><span class='line'><span class="n">most</span> <span class="n">monad</span> <span class="n">in</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">is</span> <span class="o">-</span> <span class="n">in</span> <span class="k">this</span> <span class="k">case</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nc">Option</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;.</span> <span class="nc">Without</span> <span class="k">this</span> <span class="n">knowledge</span>
</span><span class='line'><span class="n">we</span> <span class="n">can</span><span class="err">’</span><span class="n">t</span> <span class="n">compose</span> <span class="n">any</span> <span class="n">two</span> <span class="n">given</span> <span class="n">monads</span> <span class="k">with</span> <span class="n">itself</span><span class="o">.&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h4</span> <span class="n">id</span><span class="o">=</span><span class="s">&quot;monad-quick-recap&quot;</span><span class="o">&gt;</span><span class="nc">Monad</span> <span class="n">quick</span> <span class="n">recap</span><span class="o">&lt;/</span><span class="n">h4</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">A</span> <span class="n">minimal</span> <span class="n">api</span> <span class="k">for</span> <span class="n">monad</span> <span class="n">can</span> <span class="n">be</span> <span class="n">described</span> <span class="n">by</span> <span class="n">following</span> <span class="k">trait</span>
</span></code></pre></td></tr></table></div></figure>scala
trait Monad[M[_]] {</p>

<p>def pure<a href="x: A">A</a>: M[A]</p>

<p>def flatMap<a href="xs: M[A]">A, B</a>(f: A =&gt; M[B]): M[B]</p>

<p>def map<a href="xs: M[A]">A, B</a>(f: A =&gt; B): M[B] = flatMap(xs)(x =&gt; pure(f(x)))</p>

<p>}</p>

<p>object Monad {</p>

<p>def apply<a href="implicit m: Monad[M]">M[_]</a>: Monad[M] = m</p>

<p>}
<code>
And its instance for `Future` you can find below.
</code>scala
object MonadInstances {
  implicit def futureInstance(implicit ex: ExecutionContext): Monad[Future] =
    new Monad[Future] {</p>

<pre><code>  override def pure[A](x: A): Future[A] = Future.successful(x)

  override def flatMap[A, B](xs: Future[A])(f: A =&gt; Future[B]): Future[B] = xs.flatMap(f)(ex)
} } ```
</code></pre>

<h4 id="a-solution">A solution</h4>
<p>Putting all pieces together we can finally write
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext.Implicits.global</span>
</span><span class='line'><span class="k">import</span> <span class="nn">MonadInstances._&lt;/p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="n">findStreetByLogin</span><span class="o">(</span><span class="n">login</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">OptionT</span><span class="o">[</span><span class="kt">Future</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">user</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="nc">OptionT</span><span class="o">(</span><span class="n">findUserByLogin</span><span class="o">(</span><span class="n">login</span><span class="o">))</span>
</span><span class='line'>    <span class="n">address</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="nc">OptionT</span><span class="o">(</span><span class="n">findAddressByUserId</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="o">))</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">yield</span> <span class="n">address</span><span class="o">.</span><span class="n">street</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">of</span> <span class="n">course</span> <span class="n">we</span> <span class="n">can</span> <span class="k">return</span> <span class="n">directly</span> <span class="n">`Future[Option[String]]`</span> <span class="n">just</span> <span class="n">by</span> <span class="n">calling</span>
</span><span class='line'><span class="n">`value`</span> <span class="n">function</span> <span class="n">on</span> <span class="n">the</span> <span class="n">result</span> <span class="n">like</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">scala</span>
</span><span class='line'><span class="k">def</span> <span class="n">findStreetByLogin</span><span class="o">(</span><span class="n">login</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>  <span class="o">(</span><span class="k">for</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">user</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="nc">OptionT</span><span class="o">(</span><span class="n">findUserByLogin</span><span class="o">(</span><span class="n">login</span><span class="o">))</span>
</span><span class='line'>    <span class="n">address</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="nc">OptionT</span><span class="o">(</span><span class="n">findAddressByUserId</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="o">))</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">yield</span> <span class="n">address</span><span class="o">.</span><span class="n">street</span><span class="o">).</span><span class="n">value</span>
</span></code></pre></td></tr></table></div></figure>
`
and that’s it.</p>

<h4 id="final-word">Final word</h4>

<p>At the beginning I said that I have two cases to show, but because the
post could be to long to go through without a brake I decided to split it
into two pieces. The whole code base used in this post can be found in
the following <a href="https://github.com/ssledz/ssledz.github.io-src/tree/master/monad-transformer">link</a></p>

<p>More in <a href="/blog/2019/01/24/monad-transformers-part-2/">part 2</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gentle Introduction to Functional Programming - Live Coding Session]]></title>
    <link href="http://ssledz.github.io/blog/2018/12/05/genetle-fp-intro/"/>
    <updated>2018-12-05T21:33:42+01:00</updated>
    <id>http://ssledz.github.io/blog/2018/12/05/genetle-fp-intro</id>
    <content type="html"><![CDATA[<p>Slides for Lunch2Learn (L2L) session are available <a href="/presentations/gentle-fp-intro.html">here</a>.</p>
]]></content>
  </entry>
  
</feed>
